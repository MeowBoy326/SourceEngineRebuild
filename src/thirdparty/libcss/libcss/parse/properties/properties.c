
/*********************************************************************************
autogenerated_align_content
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * align_content:CSS_PROP_ALIGN_CONTENT IDENT:( INHERIT: STRETCH:0,ALIGN_CONTENT_STRETCH FLEX_START:0,ALIGN_CONTENT_FLEX_START FLEX_END:0,ALIGN_CONTENT_FLEX_END CENTER:0,ALIGN_CONTENT_CENTER SPACE_BETWEEN:0,ALIGN_CONTENT_SPACE_BETWEEN SPACE_AROUND:0,ALIGN_CONTENT_SPACE_AROUND SPACE_EVENLY:0,ALIGN_CONTENT_SPACE_EVENLY IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse align_content
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_align_content(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_ALIGN_CONTENT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[STRETCH], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_CONTENT, 0, ALIGN_CONTENT_STRETCH);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX_START], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_CONTENT, 0, ALIGN_CONTENT_FLEX_START);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX_END], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_CONTENT, 0, ALIGN_CONTENT_FLEX_END);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CENTER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_CONTENT, 0, ALIGN_CONTENT_CENTER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SPACE_BETWEEN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_CONTENT, 0, ALIGN_CONTENT_SPACE_BETWEEN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SPACE_AROUND], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_CONTENT, 0, ALIGN_CONTENT_SPACE_AROUND);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SPACE_EVENLY], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_CONTENT, 0, ALIGN_CONTENT_SPACE_EVENLY);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_align_items
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * align_items:CSS_PROP_ALIGN_ITEMS IDENT:( INHERIT: STRETCH:0,ALIGN_ITEMS_STRETCH FLEX_START:0,ALIGN_ITEMS_FLEX_START FLEX_END:0,ALIGN_ITEMS_FLEX_END CENTER:0,ALIGN_ITEMS_CENTER BASELINE:0,ALIGN_ITEMS_BASELINE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse align_items
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_align_items(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_ALIGN_ITEMS);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[STRETCH], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_ITEMS, 0, ALIGN_ITEMS_STRETCH);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX_START], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_ITEMS, 0, ALIGN_ITEMS_FLEX_START);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX_END], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_ITEMS, 0, ALIGN_ITEMS_FLEX_END);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CENTER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_ITEMS, 0, ALIGN_ITEMS_CENTER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[BASELINE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_ITEMS, 0, ALIGN_ITEMS_BASELINE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_align_self
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * align_self:CSS_PROP_ALIGN_SELF IDENT:( INHERIT: STRETCH:0,ALIGN_SELF_STRETCH FLEX_START:0,ALIGN_SELF_FLEX_START FLEX_END:0,ALIGN_SELF_FLEX_END CENTER:0,ALIGN_SELF_CENTER BASELINE:0,ALIGN_SELF_BASELINE AUTO:0,ALIGN_SELF_AUTO IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse align_self
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_align_self(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_ALIGN_SELF);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[STRETCH], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_SELF, 0, ALIGN_SELF_STRETCH);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX_START], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_SELF, 0, ALIGN_SELF_FLEX_START);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX_END], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_SELF, 0, ALIGN_SELF_FLEX_END);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CENTER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_SELF, 0, ALIGN_SELF_CENTER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[BASELINE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_SELF, 0, ALIGN_SELF_BASELINE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ALIGN_SELF, 0, ALIGN_SELF_AUTO);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_background_attachment
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * background_attachment:CSS_PROP_BACKGROUND_ATTACHMENT IDENT:( INHERIT: FIXED:0,BACKGROUND_ATTACHMENT_FIXED SCROLL:0,BACKGROUND_ATTACHMENT_SCROLL IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse background_attachment
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_background_attachment(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_ATTACHMENT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FIXED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_ATTACHMENT, 0, BACKGROUND_ATTACHMENT_FIXED);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SCROLL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_ATTACHMENT, 0, BACKGROUND_ATTACHMENT_SCROLL);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_background_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * background_color:CSS_PROP_BACKGROUND_COLOR IDENT:( INHERIT: IDENT:) COLOR:BACKGROUND_COLOR_SET
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse background_color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_background_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_COLOR);
    }
    else {
        uint16_t value = 0;
        uint32_t color = 0;
        *ctx = orig_ctx;

        error = css__parse_colour_specifier(c, vector, ctx, &value, &color);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_COLOR, 0, value);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (value == COLOR_SET)
            error = css__stylesheet_style_append(result, color);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_background_image
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * background_image:CSS_PROP_BACKGROUND_IMAGE IDENT:( INHERIT: NONE:0,BACKGROUND_IMAGE_NONE IDENT:) URI:BACKGROUND_IMAGE_URI
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse background_image
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_background_image(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_URI))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_IMAGE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_IMAGE, 0, BACKGROUND_IMAGE_NONE);
    }
    else if (token->type == CSS_TOKEN_URI) {
        lwc_string* uri = NULL;
        uint32_t uri_snumber;

        error = c->sheet->resolve(c->sheet->resolve_pw,
            c->sheet->url,
            token->idata, &uri);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_string_add(c->sheet, uri, &uri_snumber);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_IMAGE, 0, BACKGROUND_IMAGE_URI);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, uri_snumber);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_background_repeat
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * background_repeat:CSS_PROP_BACKGROUND_REPEAT IDENT:( INHERIT: NO_REPEAT:0,BACKGROUND_REPEAT_NO_REPEAT REPEAT_X:0,BACKGROUND_REPEAT_REPEAT_X REPEAT_Y:0,BACKGROUND_REPEAT_REPEAT_Y REPEAT:0,BACKGROUND_REPEAT_REPEAT IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse background_repeat
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_background_repeat(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_REPEAT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NO_REPEAT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_REPEAT, 0, BACKGROUND_REPEAT_NO_REPEAT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[REPEAT_X], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_REPEAT, 0, BACKGROUND_REPEAT_REPEAT_X);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[REPEAT_Y], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_REPEAT, 0, BACKGROUND_REPEAT_REPEAT_Y);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[REPEAT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_REPEAT, 0, BACKGROUND_REPEAT_REPEAT);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_border_bottom
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_bottom:BORDER_SIDE_BOTTOM WRAP:css__parse_border_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_bottom
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_bottom(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side(c, vector, ctx, result, BORDER_SIDE_BOTTOM);
}

/*********************************************************************************
autogenerated_border_bottom_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_bottom_color:CSS_PROP_BORDER_BOTTOM_COLOR WRAP:css__parse_border_side_color
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_bottom_color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_bottom_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_color(c, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_COLOR);
}

/*********************************************************************************
autogenerated_border_bottom_left_radius
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_bottom_left_radius:CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS WRAP:css__parse_border_radius_corner
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_bottom_left_radius
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_bottom_left_radius(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_radius_corner(c, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS);
}

/*********************************************************************************
autogenerated_border_bottom_right_radius
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_bottom_right_radius:CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS WRAP:css__parse_border_radius_corner
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_bottom_right_radius
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_bottom_right_radius(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_radius_corner(c, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS);
}

/*********************************************************************************
autogenerated_border_bottom_style
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_bottom_style:CSS_PROP_BORDER_BOTTOM_STYLE WRAP:css__parse_border_side_style
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_bottom_style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_bottom_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_style(c, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_STYLE);
}

/*********************************************************************************
autogenerated_border_bottom_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_bottom_width:CSS_PROP_BORDER_BOTTOM_WIDTH WRAP:css__parse_border_side_width
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_bottom_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_bottom_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_width(c, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_WIDTH);
}

/*********************************************************************************
autogenerated_border_collapse
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_collapse:CSS_PROP_BORDER_COLLAPSE IDENT:( INHERIT: COLLAPSE:0,BORDER_COLLAPSE_COLLAPSE SEPARATE:0,BORDER_COLLAPSE_SEPARATE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_collapse
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_collapse(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_COLLAPSE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[COLLAPSE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BORDER_COLLAPSE, 0, BORDER_COLLAPSE_COLLAPSE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SEPARATE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BORDER_COLLAPSE, 0, BORDER_COLLAPSE_SEPARATE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_border_left
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_left:BORDER_SIDE_LEFT WRAP:css__parse_border_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_left
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_left(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side(c, vector, ctx, result, BORDER_SIDE_LEFT);
}

/*********************************************************************************
autogenerated_border_left_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_left_color:CSS_PROP_BORDER_LEFT_COLOR WRAP:css__parse_border_side_color
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_left_color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_left_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_color(c, vector, ctx, result, CSS_PROP_BORDER_LEFT_COLOR);
}

/*********************************************************************************
autogenerated_border_left_style
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_left_style:CSS_PROP_BORDER_LEFT_STYLE WRAP:css__parse_border_side_style
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_left_style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_left_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_style(c, vector, ctx, result, CSS_PROP_BORDER_LEFT_STYLE);
}

/*********************************************************************************
autogenerated_border_left_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_left_width:CSS_PROP_BORDER_LEFT_WIDTH WRAP:css__parse_border_side_width
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_left_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_left_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_width(c, vector, ctx, result, CSS_PROP_BORDER_LEFT_WIDTH);
}

/*********************************************************************************
autogenerated_border_radius_bottom_left
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_radius_bottom_left:CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS WRAP:css__parse_border_radius_corner
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_radius_bottom_left
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_radius_bottom_left(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_radius_corner(c, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS);
}

/*********************************************************************************
autogenerated_border_radius_bottom_right
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_radius_bottom_right:CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS WRAP:css__parse_border_radius_corner
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_radius_bottom_right
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_radius_bottom_right(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_radius_corner(c, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS);
}

/*********************************************************************************
autogenerated_border_radius_corner
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_radius_corner:op GENERIC: IDENT:INHERIT LENGTH_UNIT:( UNIT_PX:BORDER_RADIUS_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_radius_corner
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \param op	 Bytecode OpCode for CSS property to encode
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_radius_corner(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result, enum css_properties_e op)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, op);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_RADIUS_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_border_radius_top_left
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_radius_top_left:CSS_PROP_BORDER_TOP_LEFT_RADIUS WRAP:css__parse_border_radius_corner
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_radius_top_left
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_radius_top_left(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_radius_corner(c, vector, ctx, result, CSS_PROP_BORDER_TOP_LEFT_RADIUS);
}

/*********************************************************************************
autogenerated_border_radius_top_right
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_radius_top_right:CSS_PROP_BORDER_TOP_RIGHT_RADIUS WRAP:css__parse_border_radius_corner
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_radius_top_right
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_radius_top_right(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_radius_corner(c, vector, ctx, result, CSS_PROP_BORDER_TOP_RIGHT_RADIUS);
}

/*********************************************************************************
autogenerated_border_right
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_right:BORDER_SIDE_RIGHT WRAP:css__parse_border_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_right
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_right(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side(c, vector, ctx, result, BORDER_SIDE_RIGHT);
}

/*********************************************************************************
autogenerated_border_right_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_right_color:CSS_PROP_BORDER_RIGHT_COLOR WRAP:css__parse_border_side_color
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_right_color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_right_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_color(c, vector, ctx, result, CSS_PROP_BORDER_RIGHT_COLOR);
}

/*********************************************************************************
autogenerated_border_right_style
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_right_style:CSS_PROP_BORDER_RIGHT_STYLE WRAP:css__parse_border_side_style
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_right_style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_right_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_style(c, vector, ctx, result, CSS_PROP_BORDER_RIGHT_STYLE);
}

/*********************************************************************************
autogenerated_border_right_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_right_width:CSS_PROP_BORDER_RIGHT_WIDTH WRAP:css__parse_border_side_width
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_right_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_right_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_width(c, vector, ctx, result, CSS_PROP_BORDER_RIGHT_WIDTH);
}

/*********************************************************************************
autogenerated_border_side_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_side_color:op GENERIC: IDENT:( INHERIT: IDENT:) COLOR:BORDER_COLOR_SET
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_side_color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \param op	 Bytecode OpCode for CSS property to encode
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_side_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result, enum css_properties_e op)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, op);
    }
    else {
        uint16_t value = 0;
        uint32_t color = 0;
        *ctx = orig_ctx;

        error = css__parse_colour_specifier(c, vector, ctx, &value, &color);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, op, 0, value);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (value == COLOR_SET)
            error = css__stylesheet_style_append(result, color);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_border_side_style
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_side_style:op GENERIC: IDENT:( INHERIT: NONE:0,BORDER_STYLE_NONE HIDDEN:0,BORDER_STYLE_HIDDEN DOTTED:0,BORDER_STYLE_DOTTED DASHED:0,BORDER_STYLE_DASHED SOLID:0,BORDER_STYLE_SOLID LIBCSS_DOUBLE:0,BORDER_STYLE_DOUBLE GROOVE:0,BORDER_STYLE_GROOVE RIDGE:0,BORDER_STYLE_RIDGE INSET:0,BORDER_STYLE_INSET OUTSET:0,BORDER_STYLE_OUTSET IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_side_style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \param op	 Bytecode OpCode for CSS property to encode
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_side_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result, enum css_properties_e op)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, op);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_NONE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[HIDDEN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_HIDDEN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[DOTTED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_DOTTED);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[DASHED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_DASHED);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SOLID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_SOLID);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIBCSS_DOUBLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_DOUBLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[GROOVE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_GROOVE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIDGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_RIDGE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[INSET], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_INSET);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[OUTSET], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_STYLE_OUTSET);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_border_side_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_side_width:op GENERIC: IDENT:( INHERIT: THIN:0,BORDER_WIDTH_THIN MEDIUM:0,BORDER_WIDTH_MEDIUM THICK:0,BORDER_WIDTH_THICK IDENT:) LENGTH_UNIT:( UNIT_PX:BORDER_WIDTH_SET DISALLOW:unit==UNIT_PCT||unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_side_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \param op	 Bytecode OpCode for CSS property to encode
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_side_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result, enum css_properties_e op)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, op);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[THIN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_WIDTH_THIN);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[MEDIUM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_WIDTH_MEDIUM);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[THICK], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_WIDTH_THICK);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit == UNIT_PCT || unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, op, 0, BORDER_WIDTH_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_border_top
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_top:BORDER_SIDE_TOP WRAP:css__parse_border_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_top
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_top(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side(c, vector, ctx, result, BORDER_SIDE_TOP);
}

/*********************************************************************************
autogenerated_border_top_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_top_color:CSS_PROP_BORDER_TOP_COLOR WRAP:css__parse_border_side_color
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_top_color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_top_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_color(c, vector, ctx, result, CSS_PROP_BORDER_TOP_COLOR);
}

/*********************************************************************************
autogenerated_border_top_left_radius
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_top_left_radius:CSS_PROP_BORDER_TOP_LEFT_RADIUS WRAP:css__parse_border_radius_corner
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_top_left_radius
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_top_left_radius(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_radius_corner(c, vector, ctx, result, CSS_PROP_BORDER_TOP_LEFT_RADIUS);
}

/*********************************************************************************
autogenerated_border_top_right_radius
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_top_right_radius:CSS_PROP_BORDER_TOP_RIGHT_RADIUS WRAP:css__parse_border_radius_corner
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_top_right_radius
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_top_right_radius(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_radius_corner(c, vector, ctx, result, CSS_PROP_BORDER_TOP_RIGHT_RADIUS);
}

/*********************************************************************************
autogenerated_border_top_style
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_top_style:CSS_PROP_BORDER_TOP_STYLE WRAP:css__parse_border_side_style
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_top_style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_top_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_style(c, vector, ctx, result, CSS_PROP_BORDER_TOP_STYLE);
}

/*********************************************************************************
autogenerated_border_top_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * border_top_width:CSS_PROP_BORDER_TOP_WIDTH WRAP:css__parse_border_side_width
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border_top_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_top_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_width(c, vector, ctx, result, CSS_PROP_BORDER_TOP_WIDTH);
}

/*********************************************************************************
autogenerated_bottom
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * bottom:CSS_PROP_BOTTOM WRAP:css__parse_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse bottom
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_bottom(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_side(c, vector, ctx, result, CSS_PROP_BOTTOM);
}

/*********************************************************************************
autogenerated_box_sizing
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * box_sizing:CSS_PROP_BOX_SIZING IDENT:( INHERIT: CONTENT_BOX:0,BOX_SIZING_CONTENT_BOX BORDER_BOX:0,BOX_SIZING_BORDER_BOX IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse box_sizing
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_box_sizing(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BOX_SIZING);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CONTENT_BOX], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BOX_SIZING, 0, BOX_SIZING_CONTENT_BOX);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[BORDER_BOX], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BOX_SIZING, 0, BOX_SIZING_BORDER_BOX);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_break_after
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * break_after:CSS_PROP_BREAK_AFTER IDENT:( INHERIT: AUTO:0,BREAK_AFTER_AUTO ALWAYS:0,BREAK_AFTER_ALWAYS AVOID:0,BREAK_AFTER_AVOID LEFT:0,BREAK_AFTER_LEFT RIGHT:0,BREAK_AFTER_RIGHT PAGE:0,BREAK_AFTER_PAGE COLUMN:0,BREAK_AFTER_COLUMN AVOID_PAGE:0,BREAK_AFTER_AVOID_PAGE AVOID_COLUMN:0,BREAK_AFTER_AVOID_COLUMN IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse break_after
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_break_after(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BREAK_AFTER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_AUTO);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ALWAYS], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_ALWAYS);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_AVOID);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LEFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_LEFT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIGHT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_RIGHT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[PAGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_PAGE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[COLUMN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_COLUMN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID_PAGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_AVOID_PAGE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID_COLUMN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0, BREAK_AFTER_AVOID_COLUMN);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_break_before
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * break_before:CSS_PROP_BREAK_BEFORE IDENT:( INHERIT: AUTO:0,BREAK_BEFORE_AUTO ALWAYS:0,BREAK_BEFORE_ALWAYS AVOID:0,BREAK_BEFORE_AVOID LEFT:0,BREAK_BEFORE_LEFT RIGHT:0,BREAK_BEFORE_RIGHT PAGE:0,BREAK_BEFORE_PAGE COLUMN:0,BREAK_BEFORE_COLUMN AVOID_PAGE:0,BREAK_BEFORE_AVOID_PAGE AVOID_COLUMN:0,BREAK_BEFORE_AVOID_COLUMN IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse break_before
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_break_before(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BREAK_BEFORE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_AUTO);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ALWAYS], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_ALWAYS);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_AVOID);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LEFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_LEFT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIGHT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_RIGHT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[PAGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_PAGE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[COLUMN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_COLUMN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID_PAGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_AVOID_PAGE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID_COLUMN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0, BREAK_BEFORE_AVOID_COLUMN);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_break_inside
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * break_inside:CSS_PROP_BREAK_INSIDE IDENT:( INHERIT: AUTO:0,BREAK_INSIDE_AUTO AVOID:0,BREAK_INSIDE_AVOID AVOID_PAGE:0,BREAK_INSIDE_AVOID_PAGE AVOID_COLUMN:0,BREAK_INSIDE_AVOID_COLUMN IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse break_inside
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_break_inside(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BREAK_INSIDE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_INSIDE, 0, BREAK_INSIDE_AUTO);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_INSIDE, 0, BREAK_INSIDE_AVOID);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID_PAGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_INSIDE, 0, BREAK_INSIDE_AVOID_PAGE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID_COLUMN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_INSIDE, 0, BREAK_INSIDE_AVOID_COLUMN);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_caption_side
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * caption_side:CSS_PROP_CAPTION_SIDE IDENT:( INHERIT: TOP:0,CAPTION_SIDE_TOP BOTTOM:0,CAPTION_SIDE_BOTTOM IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse caption_side
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_caption_side(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_CAPTION_SIDE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TOP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CAPTION_SIDE, 0, CAPTION_SIDE_TOP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[BOTTOM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CAPTION_SIDE, 0, CAPTION_SIDE_BOTTOM);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_clear
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * clear:CSS_PROP_CLEAR IDENT:( INHERIT: RIGHT:0,CLEAR_RIGHT LEFT:0,CLEAR_LEFT BOTH:0,CLEAR_BOTH NONE:0,CLEAR_NONE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse clear
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_clear(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_CLEAR);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIGHT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CLEAR, 0, CLEAR_RIGHT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LEFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CLEAR, 0, CLEAR_LEFT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[BOTH], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CLEAR, 0, CLEAR_BOTH);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CLEAR, 0, CLEAR_NONE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * color:CSS_PROP_COLOR IDENT:INHERIT COLOR:COLOR_SET
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COLOR);
    }
    else {
        uint16_t value = 0;
        uint32_t color = 0;
        *ctx = orig_ctx;

        error = css__parse_colour_specifier(c, vector, ctx, &value, &color);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLOR, 0, value);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (value == COLOR_SET)
            error = css__stylesheet_style_append(result, color);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_column_count
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * column_count:CSS_PROP_COLUMN_COUNT IDENT:( INHERIT: AUTO:0,COLUMN_COUNT_AUTO IDENT:) NUMBER:( true:COLUMN_COUNT_SET RANGE:num<0 NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column_count
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_count(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_COUNT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_COUNT, 0, COLUMN_COUNT_AUTO);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, true, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_COUNT, 0, COLUMN_COUNT_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_column_fill
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * column_fill:CSS_PROP_COLUMN_FILL IDENT:( INHERIT: BALANCE:0,COLUMN_FILL_BALANCE AUTO:0,COLUMN_FILL_AUTO IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column_fill
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_fill(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_FILL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[BALANCE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_FILL, 0, COLUMN_FILL_BALANCE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_FILL, 0, COLUMN_FILL_AUTO);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_column_gap
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * column_gap:CSS_PROP_COLUMN_GAP IDENT:( INHERIT: NORMAL:0,COLUMN_GAP_NORMAL IDENT:) LENGTH_UNIT:( UNIT_PX:COLUMN_GAP_SET RANGE:<0 DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ||unit&UNIT_PCT LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column_gap
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_gap(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_GAP);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_GAP, 0, COLUMN_GAP_NORMAL);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ || unit & UNIT_PCT) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_GAP, 0, COLUMN_GAP_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_column_rule_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * column_rule_color:CSS_PROP_COLUMN_RULE_COLOR IDENT:( INHERIT: IDENT:) COLOR:COLUMN_RULE_COLOR_SET
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column_rule_color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_rule_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_RULE_COLOR);
    }
    else {
        uint16_t value = 0;
        uint32_t color = 0;
        *ctx = orig_ctx;

        error = css__parse_colour_specifier(c, vector, ctx, &value, &color);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_COLOR, 0, value);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (value == COLOR_SET)
            error = css__stylesheet_style_append(result, color);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_column_rule_style
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * column_rule_style:CSS_PROP_COLUMN_RULE_STYLE IDENT:( INHERIT: NONE:0,BORDER_STYLE_NONE HIDDEN:0,BORDER_STYLE_HIDDEN DOTTED:0,BORDER_STYLE_DOTTED DASHED:0,BORDER_STYLE_DASHED SOLID:0,BORDER_STYLE_SOLID LIBCSS_DOUBLE:0,BORDER_STYLE_DOUBLE GROOVE:0,BORDER_STYLE_GROOVE RIDGE:0,BORDER_STYLE_RIDGE INSET:0,BORDER_STYLE_INSET OUTSET:0,BORDER_STYLE_OUTSET IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column_rule_style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_rule_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_RULE_STYLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_NONE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[HIDDEN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_HIDDEN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[DOTTED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_DOTTED);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[DASHED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_DASHED);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SOLID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_SOLID);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIBCSS_DOUBLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_DOUBLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[GROOVE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_GROOVE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIDGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_RIDGE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[INSET], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_INSET);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[OUTSET], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0, BORDER_STYLE_OUTSET);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_column_rule_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * column_rule_width:CSS_PROP_COLUMN_RULE_WIDTH WRAP:css__parse_border_side_width
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column_rule_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_rule_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_width(c, vector, ctx, result, CSS_PROP_COLUMN_RULE_WIDTH);
}

/*********************************************************************************
autogenerated_column_span
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * column_span:CSS_PROP_COLUMN_SPAN IDENT:( INHERIT: NONE:0,COLUMN_SPAN_NONE ALL:0,COLUMN_SPAN_ALL IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column_span
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_span(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_SPAN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_SPAN, 0, COLUMN_SPAN_NONE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ALL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_SPAN, 0, COLUMN_SPAN_ALL);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_column_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * column_width:CSS_PROP_COLUMN_WIDTH IDENT:( INHERIT: AUTO:0,COLUMN_WIDTH_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:COLUMN_WIDTH_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ||unit&UNIT_PCT LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_WIDTH);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_WIDTH, 0, COLUMN_WIDTH_AUTO);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ || unit & UNIT_PCT) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_WIDTH, 0, COLUMN_WIDTH_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_counter_increment
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * counter_increment:CSS_PROP_COUNTER_INCREMENT IDENT:( INHERIT: NONE:0,COUNTER_INCREMENT_NONE IDENT:) IDENT_LIST:( STRING_OPTNUM:COUNTER_INCREMENT_NAMED 1:COUNTER_INCREMENT_NONE IDENT_LIST:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse counter_increment
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_counter_increment(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COUNTER_INCREMENT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COUNTER_INCREMENT, 0, COUNTER_INCREMENT_NONE);
    }
    else {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COUNTER_INCREMENT, 0, COUNTER_INCREMENT_NAMED);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        while ((token != NULL) && (token->type == CSS_TOKEN_IDENT)) {
            uint32_t snumber;
            css_fixed num;
            int pctx;

            error = css__stylesheet_string_add(c->sheet, lwc_string_ref(token->idata), &snumber);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            error = css__stylesheet_style_append(result, snumber);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            consumeWhitespace(vector, ctx);

            pctx = *ctx;
            token = parserutils_vector_iterate(vector, ctx);
            if ((token != NULL) && (token->type == CSS_TOKEN_NUMBER)) {
                size_t consumed = 0;

                num = css__number_from_lwc_string(token->idata, true, &consumed);
                if (consumed != lwc_string_length(token->idata)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
                consumeWhitespace(vector, ctx);

                pctx = *ctx;
                token = parserutils_vector_iterate(vector, ctx);
            }
            else {
                num = INTTOFIX(1);
            }

            error = css__stylesheet_style_append(result, num);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            if (token == NULL)
                break;

            if (token->type == CSS_TOKEN_IDENT) {
                error = css__stylesheet_style_append(result, COUNTER_INCREMENT_NAMED);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }
            }
            else {
                *ctx = pctx; /* rewind one token back */
            }
        }

        error = css__stylesheet_style_append(result, COUNTER_INCREMENT_NONE);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_counter_reset
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * counter_reset:CSS_PROP_COUNTER_RESET IDENT:( INHERIT: NONE:0,COUNTER_RESET_NONE IDENT:) IDENT_LIST:( STRING_OPTNUM:COUNTER_RESET_NAMED 0:COUNTER_RESET_NONE IDENT_LIST:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse counter_reset
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_counter_reset(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_COUNTER_RESET);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COUNTER_RESET, 0, COUNTER_RESET_NONE);
    }
    else {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_COUNTER_RESET, 0, COUNTER_RESET_NAMED);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        while ((token != NULL) && (token->type == CSS_TOKEN_IDENT)) {
            uint32_t snumber;
            css_fixed num;
            int pctx;

            error = css__stylesheet_string_add(c->sheet, lwc_string_ref(token->idata), &snumber);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            error = css__stylesheet_style_append(result, snumber);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            consumeWhitespace(vector, ctx);

            pctx = *ctx;
            token = parserutils_vector_iterate(vector, ctx);
            if ((token != NULL) && (token->type == CSS_TOKEN_NUMBER)) {
                size_t consumed = 0;

                num = css__number_from_lwc_string(token->idata, true, &consumed);
                if (consumed != lwc_string_length(token->idata)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
                consumeWhitespace(vector, ctx);

                pctx = *ctx;
                token = parserutils_vector_iterate(vector, ctx);
            }
            else {
                num = INTTOFIX(0);
            }

            error = css__stylesheet_style_append(result, num);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            if (token == NULL)
                break;

            if (token->type == CSS_TOKEN_IDENT) {
                error = css__stylesheet_style_append(result, COUNTER_RESET_NAMED);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }
            }
            else {
                *ctx = pctx; /* rewind one token back */
            }
        }

        error = css__stylesheet_style_append(result, COUNTER_RESET_NONE);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_cue_after
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * cue_after:CSS_PROP_CUE_AFTER IDENT:( INHERIT: NONE:0,CUE_AFTER_NONE IDENT:) URI:CUE_AFTER_URI
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse cue_after
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_cue_after(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_URI))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_CUE_AFTER);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CUE_AFTER, 0, CUE_AFTER_NONE);
    }
    else if (token->type == CSS_TOKEN_URI) {
        lwc_string* uri = NULL;
        uint32_t uri_snumber;

        error = c->sheet->resolve(c->sheet->resolve_pw,
            c->sheet->url,
            token->idata, &uri);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_string_add(c->sheet, uri, &uri_snumber);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CUE_AFTER, 0, CUE_AFTER_URI);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, uri_snumber);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_cue_before
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * cue_before:CSS_PROP_CUE_BEFORE IDENT:( INHERIT: NONE:0,CUE_BEFORE_NONE IDENT:) URI:CUE_BEFORE_URI
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse cue_before
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_cue_before(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_URI))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_CUE_BEFORE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CUE_BEFORE, 0, CUE_BEFORE_NONE);
    }
    else if (token->type == CSS_TOKEN_URI) {
        lwc_string* uri = NULL;
        uint32_t uri_snumber;

        error = c->sheet->resolve(c->sheet->resolve_pw,
            c->sheet->url,
            token->idata, &uri);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_string_add(c->sheet, uri, &uri_snumber);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CUE_BEFORE, 0, CUE_BEFORE_URI);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, uri_snumber);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_direction
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * direction:CSS_PROP_DIRECTION IDENT:( INHERIT: LTR:0,DIRECTION_LTR RTL:0,DIRECTION_RTL IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse direction
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_direction(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_DIRECTION);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LTR], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DIRECTION, 0, DIRECTION_LTR);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RTL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DIRECTION, 0, DIRECTION_RTL);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_display
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * display:CSS_PROP_DISPLAY IDENT:( INHERIT: INLINE:0,DISPLAY_INLINE BLOCK:0,DISPLAY_BLOCK LIST_ITEM:0,DISPLAY_LIST_ITEM RUN_IN:0,DISPLAY_RUN_IN INLINE_BLOCK:0,DISPLAY_INLINE_BLOCK TABLE:0,DISPLAY_TABLE INLINE_TABLE:0,DISPLAY_INLINE_TABLE TABLE_ROW_GROUP:0,DISPLAY_TABLE_ROW_GROUP TABLE_HEADER_GROUP:0,DISPLAY_TABLE_HEADER_GROUP TABLE_FOOTER_GROUP:0,DISPLAY_TABLE_FOOTER_GROUP TABLE_ROW:0,DISPLAY_TABLE_ROW TABLE_COLUMN_GROUP:0,DISPLAY_TABLE_COLUMN_GROUP TABLE_COLUMN:0,DISPLAY_TABLE_COLUMN TABLE_CELL:0,DISPLAY_TABLE_CELL TABLE_CAPTION:0,DISPLAY_TABLE_CAPTION NONE:0,DISPLAY_NONE FLEX:0,DISPLAY_FLEX INLINE_FLEX:0,DISPLAY_INLINE_FLEX IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse display
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_display(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_DISPLAY);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[INLINE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_INLINE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[BLOCK], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_BLOCK);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIST_ITEM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_LIST_ITEM);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RUN_IN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_RUN_IN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[INLINE_BLOCK], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_INLINE_BLOCK);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[INLINE_TABLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_INLINE_TABLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE_ROW_GROUP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE_ROW_GROUP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE_HEADER_GROUP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE_HEADER_GROUP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE_FOOTER_GROUP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE_FOOTER_GROUP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE_ROW], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE_ROW);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE_COLUMN_GROUP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE_COLUMN_GROUP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE_COLUMN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE_COLUMN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE_CELL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE_CELL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[TABLE_CAPTION], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_TABLE_CAPTION);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_NONE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_FLEX);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[INLINE_FLEX], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0, DISPLAY_INLINE_FLEX);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_empty_cells
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * empty_cells:CSS_PROP_EMPTY_CELLS IDENT:( INHERIT: SHOW:0,EMPTY_CELLS_SHOW HIDE:0,EMPTY_CELLS_HIDE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse empty_cells
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_empty_cells(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_EMPTY_CELLS);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SHOW], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_EMPTY_CELLS, 0, EMPTY_CELLS_SHOW);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[HIDE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_EMPTY_CELLS, 0, EMPTY_CELLS_HIDE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_flex_basis
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * flex_basis:CSS_PROP_FLEX_BASIS IDENT:( INHERIT: AUTO:0,FLEX_BASIS_AUTO CONTENT:0,FLEX_BASIS_CONTENT IDENT:) LENGTH_UNIT:( UNIT_PX:FLEX_BASIS_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse flex_basis
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_flex_basis(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FLEX_BASIS);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_BASIS, 0, FLEX_BASIS_AUTO);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[CONTENT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_BASIS, 0, FLEX_BASIS_CONTENT);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_BASIS, 0, FLEX_BASIS_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_flex_direction
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * flex_direction:CSS_PROP_FLEX_DIRECTION IDENT:( INHERIT: ROW:0,FLEX_DIRECTION_ROW ROW_REVERSE:0,FLEX_DIRECTION_ROW_REVERSE COLUMN:0,FLEX_DIRECTION_COLUMN COLUMN_REVERSE:0,FLEX_DIRECTION_COLUMN_REVERSE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse flex_direction
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_flex_direction(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FLEX_DIRECTION);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ROW], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_DIRECTION, 0, FLEX_DIRECTION_ROW);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ROW_REVERSE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_DIRECTION, 0, FLEX_DIRECTION_ROW_REVERSE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[COLUMN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_DIRECTION, 0, FLEX_DIRECTION_COLUMN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[COLUMN_REVERSE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_DIRECTION, 0, FLEX_DIRECTION_COLUMN_REVERSE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_flex_grow
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * flex_grow:CSS_PROP_FLEX_GROW IDENT:INHERIT NUMBER:( false:FLEX_GROW_SET RANGE:num<0 NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse flex_grow
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_flex_grow(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FLEX_GROW);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_GROW, 0, FLEX_GROW_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_flex_shrink
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * flex_shrink:CSS_PROP_FLEX_SHRINK IDENT:INHERIT NUMBER:( false:FLEX_SHRINK_SET RANGE:num<0 NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse flex_shrink
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_flex_shrink(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FLEX_SHRINK);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_SHRINK, 0, FLEX_SHRINK_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_flex_wrap
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * flex_wrap:CSS_PROP_FLEX_WRAP IDENT:( INHERIT: NOWRAP:0,FLEX_WRAP_NOWRAP WRAP_STRING:0,FLEX_WRAP_WRAP WRAP_REVERSE:0,FLEX_WRAP_WRAP_REVERSE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse flex_wrap
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_flex_wrap(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FLEX_WRAP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NOWRAP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_WRAP, 0, FLEX_WRAP_NOWRAP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[WRAP_STRING], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_WRAP, 0, FLEX_WRAP_WRAP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[WRAP_REVERSE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLEX_WRAP, 0, FLEX_WRAP_WRAP_REVERSE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_float
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * float:CSS_PROP_FLOAT IDENT:( INHERIT: LEFT:0,FLOAT_LEFT RIGHT:0,FLOAT_RIGHT NONE:0,FLOAT_NONE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse float
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_float(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FLOAT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LEFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLOAT, 0, FLOAT_LEFT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIGHT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLOAT, 0, FLOAT_RIGHT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FLOAT, 0, FLOAT_NONE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_font_size
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * font_size:CSS_PROP_FONT_SIZE IDENT:( INHERIT: XX_SMALL:0,FONT_SIZE_XX_SMALL X_SMALL:0,FONT_SIZE_X_SMALL SMALL:0,FONT_SIZE_SMALL MEDIUM:0,FONT_SIZE_MEDIUM LARGE:0,FONT_SIZE_LARGE X_LARGE:0,FONT_SIZE_X_LARGE XX_LARGE:0,FONT_SIZE_XX_LARGE LARGER:0,FONT_SIZE_LARGER SMALLER:0,FONT_SIZE_SMALLER IDENT:) LENGTH_UNIT:( UNIT_PX:FONT_SIZE_DIMENSION DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse font_size
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_font_size(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_SIZE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[XX_SMALL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_XX_SMALL);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[X_SMALL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_X_SMALL);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[SMALL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_SMALL);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[MEDIUM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_MEDIUM);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[LARGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_LARGE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[X_LARGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_X_LARGE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[XX_LARGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_XX_LARGE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[LARGER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_LARGER);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[SMALLER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_SMALLER);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_DIMENSION);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_font_style
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * font_style:CSS_PROP_FONT_STYLE IDENT:( INHERIT: NORMAL:0,FONT_STYLE_NORMAL ITALIC:0,FONT_STYLE_ITALIC OBLIQUE:0,FONT_STYLE_OBLIQUE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse font_style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_font_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_STYLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0, FONT_STYLE_NORMAL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ITALIC], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0, FONT_STYLE_ITALIC);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[OBLIQUE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0, FONT_STYLE_OBLIQUE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_font_variant
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * font_variant:CSS_PROP_FONT_VARIANT IDENT:( INHERIT: NORMAL:0,FONT_VARIANT_NORMAL SMALL_CAPS:0,FONT_VARIANT_SMALL_CAPS IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse font_variant
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_font_variant(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_VARIANT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_VARIANT, 0, FONT_VARIANT_NORMAL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SMALL_CAPS], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_VARIANT, 0, FONT_VARIANT_SMALL_CAPS);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_height
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * height:CSS_PROP_HEIGHT IDENT:( INHERIT: AUTO:0,HEIGHT_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:HEIGHT_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse height
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_height(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_HEIGHT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_HEIGHT, 0, HEIGHT_AUTO);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_HEIGHT, 0, HEIGHT_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_justify_content
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * justify_content:CSS_PROP_JUSTIFY_CONTENT IDENT:( INHERIT: FLEX_START:0,JUSTIFY_CONTENT_FLEX_START FLEX_END:0,JUSTIFY_CONTENT_FLEX_END CENTER:0,JUSTIFY_CONTENT_CENTER SPACE_BETWEEN:0,JUSTIFY_CONTENT_SPACE_BETWEEN SPACE_AROUND:0,JUSTIFY_CONTENT_SPACE_AROUND SPACE_EVENLY:0,JUSTIFY_CONTENT_SPACE_EVENLY IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse justify_content
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_justify_content(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_JUSTIFY_CONTENT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX_START], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_JUSTIFY_CONTENT, 0, JUSTIFY_CONTENT_FLEX_START);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FLEX_END], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_JUSTIFY_CONTENT, 0, JUSTIFY_CONTENT_FLEX_END);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CENTER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_JUSTIFY_CONTENT, 0, JUSTIFY_CONTENT_CENTER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SPACE_BETWEEN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_JUSTIFY_CONTENT, 0, JUSTIFY_CONTENT_SPACE_BETWEEN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SPACE_AROUND], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_JUSTIFY_CONTENT, 0, JUSTIFY_CONTENT_SPACE_AROUND);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SPACE_EVENLY], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_JUSTIFY_CONTENT, 0, JUSTIFY_CONTENT_SPACE_EVENLY);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_left
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * left:CSS_PROP_LEFT WRAP:css__parse_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse left
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_left(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_side(c, vector, ctx, result, CSS_PROP_LEFT);
}

/*********************************************************************************
autogenerated_letter_spacing
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * letter_spacing:CSS_PROP_LETTER_SPACING IDENT:( INHERIT: NORMAL:0,LETTER_SPACING_NORMAL IDENT:) LENGTH_UNIT:( UNIT_PX:LETTER_SPACING_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ||unit&UNIT_PCT LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse letter_spacing
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_letter_spacing(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_LETTER_SPACING);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LETTER_SPACING, 0, LETTER_SPACING_NORMAL);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ || unit & UNIT_PCT) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LETTER_SPACING, 0, LETTER_SPACING_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_line_height
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * line_height:CSS_PROP_LINE_HEIGHT IDENT:( INHERIT: NORMAL:0,LINE_HEIGHT_NORMAL IDENT:) NUMBER:( false:LINE_HEIGHT_NUMBER RANGE:num<0 NUMBER:) LENGTH_UNIT:( UNIT_PX:LINE_HEIGHT_DIMENSION DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse line_height
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_line_height(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_LINE_HEIGHT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LINE_HEIGHT, 0, LINE_HEIGHT_NORMAL);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LINE_HEIGHT, 0, LINE_HEIGHT_NUMBER);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LINE_HEIGHT, 0, LINE_HEIGHT_DIMENSION);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_list_style_image
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * list_style_image:CSS_PROP_LIST_STYLE_IMAGE IDENT:( INHERIT: NONE:0,LIST_STYLE_IMAGE_NONE IDENT:) URI:LIST_STYLE_IMAGE_URI
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse list_style_image
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_list_style_image(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_URI))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_LIST_STYLE_IMAGE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_IMAGE, 0, LIST_STYLE_IMAGE_NONE);
    }
    else if (token->type == CSS_TOKEN_URI) {
        lwc_string* uri = NULL;
        uint32_t uri_snumber;

        error = c->sheet->resolve(c->sheet->resolve_pw,
            c->sheet->url,
            token->idata, &uri);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_string_add(c->sheet, uri, &uri_snumber);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_IMAGE, 0, LIST_STYLE_IMAGE_URI);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, uri_snumber);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_list_style_position
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * list_style_position:CSS_PROP_LIST_STYLE_POSITION IDENT:( INHERIT: INSIDE:0,LIST_STYLE_POSITION_INSIDE OUTSIDE:0,LIST_STYLE_POSITION_OUTSIDE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse list_style_position
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_list_style_position(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_LIST_STYLE_POSITION);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[INSIDE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_POSITION, 0, LIST_STYLE_POSITION_INSIDE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[OUTSIDE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_POSITION, 0, LIST_STYLE_POSITION_OUTSIDE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_margin_bottom
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * margin_bottom:CSS_PROP_MARGIN_BOTTOM WRAP:css__parse_margin_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse margin_bottom
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_margin_bottom(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_margin_side(c, vector, ctx, result, CSS_PROP_MARGIN_BOTTOM);
}

/*********************************************************************************
autogenerated_margin_left
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * margin_left:CSS_PROP_MARGIN_LEFT WRAP:css__parse_margin_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse margin_left
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_margin_left(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_margin_side(c, vector, ctx, result, CSS_PROP_MARGIN_LEFT);
}

/*********************************************************************************
autogenerated_margin_right
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * margin_right:CSS_PROP_MARGIN_RIGHT WRAP:css__parse_margin_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse margin_right
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_margin_right(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_margin_side(c, vector, ctx, result, CSS_PROP_MARGIN_RIGHT);
}

/*********************************************************************************
autogenerated_margin_side
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * margin_side:op GENERIC IDENT:( INHERIT: AUTO:0,MARGIN_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:MARGIN_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse margin_side
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \param op	 Bytecode OpCode for CSS property to encode
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_margin_side(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result, enum css_properties_e op)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, op);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, MARGIN_AUTO);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, op, 0, MARGIN_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_margin_top
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * margin_top:CSS_PROP_MARGIN_TOP WRAP:css__parse_margin_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse margin_top
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_margin_top(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_margin_side(c, vector, ctx, result, CSS_PROP_MARGIN_TOP);
}

/*********************************************************************************
autogenerated_max_height
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * max_height:CSS_PROP_MAX_HEIGHT IDENT:( INHERIT: NONE:0,MAX_HEIGHT_NONE IDENT:) LENGTH_UNIT:( UNIT_PX:MAX_HEIGHT_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse max_height
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_max_height(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_MAX_HEIGHT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_MAX_HEIGHT, 0, MAX_HEIGHT_NONE);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_MAX_HEIGHT, 0, MAX_HEIGHT_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_max_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * max_width:CSS_PROP_MAX_WIDTH IDENT:( INHERIT: NONE:0,MAX_WIDTH_NONE IDENT:) LENGTH_UNIT:( UNIT_PX:MAX_WIDTH_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse max_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_max_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_MAX_WIDTH);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_MAX_WIDTH, 0, MAX_WIDTH_NONE);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_MAX_WIDTH, 0, MAX_WIDTH_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_min_height
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * min_height:CSS_PROP_MIN_HEIGHT IDENT:( INHERIT: AUTO:0,MIN_HEIGHT_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:MIN_HEIGHT_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse min_height
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_min_height(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_MIN_HEIGHT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_MIN_HEIGHT, 0, MIN_HEIGHT_AUTO);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_MIN_HEIGHT, 0, MIN_HEIGHT_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_min_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * min_width:CSS_PROP_MIN_WIDTH IDENT:( INHERIT: AUTO:0,MIN_WIDTH_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:MIN_WIDTH_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse min_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_min_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_MIN_WIDTH);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_MIN_WIDTH, 0, MIN_WIDTH_AUTO);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_MIN_WIDTH, 0, MIN_WIDTH_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_order
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * order:CSS_PROP_ORDER IDENT:INHERIT NUMBER:( true:ORDER_SET NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse order
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_order(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_ORDER);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, true, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ORDER, 0, ORDER_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_orphans
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * orphans:CSS_PROP_ORPHANS IDENT:INHERIT NUMBER:( true:ORPHANS_SET RANGE:num<0 NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse orphans
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_orphans(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_ORPHANS);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, true, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_ORPHANS, 0, ORPHANS_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_outline_color
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * outline_color:CSS_PROP_OUTLINE_COLOR IDENT:( INHERIT: INVERT:0,OUTLINE_COLOR_INVERT IDENT:) COLOR:OUTLINE_COLOR_SET
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse outline_color
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_outline_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_OUTLINE_COLOR);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INVERT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_COLOR, 0, OUTLINE_COLOR_INVERT);
    }
    else {
        uint16_t value = 0;
        uint32_t color = 0;
        *ctx = orig_ctx;

        error = css__parse_colour_specifier(c, vector, ctx, &value, &color);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_COLOR, 0, value);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (value == COLOR_SET)
            error = css__stylesheet_style_append(result, color);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_outline_style
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * outline_style:CSS_PROP_OUTLINE_STYLE IDENT:( INHERIT: NONE:0,BORDER_STYLE_NONE DOTTED:0,BORDER_STYLE_DOTTED DASHED:0,BORDER_STYLE_DASHED SOLID:0,BORDER_STYLE_SOLID LIBCSS_DOUBLE:0,BORDER_STYLE_DOUBLE GROOVE:0,BORDER_STYLE_GROOVE RIDGE:0,BORDER_STYLE_RIDGE INSET:0,BORDER_STYLE_INSET OUTSET:0,BORDER_STYLE_OUTSET IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse outline_style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_outline_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_OUTLINE_STYLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_NONE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[DOTTED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_DOTTED);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[DASHED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_DASHED);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SOLID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_SOLID);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIBCSS_DOUBLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_DOUBLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[GROOVE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_GROOVE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIDGE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_RIDGE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[INSET], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_INSET);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[OUTSET], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0, BORDER_STYLE_OUTSET);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_outline_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * outline_width:CSS_PROP_OUTLINE_WIDTH WRAP:css__parse_border_side_width
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse outline_width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_outline_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_border_side_width(c, vector, ctx, result, CSS_PROP_OUTLINE_WIDTH);
}

/*********************************************************************************
autogenerated_overflow_x
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * overflow_x:CSS_PROP_OVERFLOW_X IDENT:( INHERIT: VISIBLE:0,OVERFLOW_VISIBLE HIDDEN:0,OVERFLOW_HIDDEN SCROLL:0,OVERFLOW_SCROLL AUTO:0,OVERFLOW_AUTO  IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse overflow_x
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_overflow_x(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_OVERFLOW_X);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[VISIBLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW_X, 0, OVERFLOW_VISIBLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[HIDDEN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW_X, 0, OVERFLOW_HIDDEN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SCROLL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW_X, 0, OVERFLOW_SCROLL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW_X, 0, OVERFLOW_AUTO);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_overflow_y
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * overflow_y:CSS_PROP_OVERFLOW_Y IDENT:( INHERIT: VISIBLE:0,OVERFLOW_VISIBLE HIDDEN:0,OVERFLOW_HIDDEN SCROLL:0,OVERFLOW_SCROLL AUTO:0,OVERFLOW_AUTO  IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse overflow_y
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_overflow_y(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_OVERFLOW_Y);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[VISIBLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW_Y, 0, OVERFLOW_VISIBLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[HIDDEN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW_Y, 0, OVERFLOW_HIDDEN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SCROLL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW_Y, 0, OVERFLOW_SCROLL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW_Y, 0, OVERFLOW_AUTO);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_padding_bottom
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * padding_bottom:CSS_PROP_PADDING_BOTTOM WRAP:css__parse_padding_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse padding_bottom
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_padding_bottom(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_padding_side(c, vector, ctx, result, CSS_PROP_PADDING_BOTTOM);
}

/*********************************************************************************
autogenerated_padding_left
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * padding_left:CSS_PROP_PADDING_LEFT WRAP:css__parse_padding_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse padding_left
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_padding_left(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_padding_side(c, vector, ctx, result, CSS_PROP_PADDING_LEFT);
}

/*********************************************************************************
autogenerated_padding_right
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * padding_right:CSS_PROP_PADDING_RIGHT WRAP:css__parse_padding_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse padding_right
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_padding_right(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_padding_side(c, vector, ctx, result, CSS_PROP_PADDING_RIGHT);
}

/*********************************************************************************
autogenerated_padding_side
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * padding_side:op GENERIC: IDENT:INHERIT LENGTH_UNIT:( UNIT_PX:PADDING_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ  RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse padding_side
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \param op	 Bytecode OpCode for CSS property to encode
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_padding_side(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result, enum css_properties_e op)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, op);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, op, 0, PADDING_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_padding_top
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * padding_top:CSS_PROP_PADDING_TOP WRAP:css__parse_padding_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse padding_top
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_padding_top(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_padding_side(c, vector, ctx, result, CSS_PROP_PADDING_TOP);
}

/*********************************************************************************
autogenerated_page_break_after
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * page_break_after:CSS_PROP_PAGE_BREAK_AFTER IDENT:( INHERIT: AUTO:0,PAGE_BREAK_AFTER_AUTO ALWAYS:0,PAGE_BREAK_AFTER_ALWAYS AVOID:0,PAGE_BREAK_AFTER_AVOID LEFT:0,PAGE_BREAK_AFTER_LEFT RIGHT:0,PAGE_BREAK_AFTER_RIGHT IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse page_break_after
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_page_break_after(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_PAGE_BREAK_AFTER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0, PAGE_BREAK_AFTER_AUTO);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ALWAYS], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0, PAGE_BREAK_AFTER_ALWAYS);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0, PAGE_BREAK_AFTER_AVOID);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LEFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0, PAGE_BREAK_AFTER_LEFT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIGHT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0, PAGE_BREAK_AFTER_RIGHT);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_page_break_before
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * page_break_before:CSS_PROP_PAGE_BREAK_BEFORE IDENT:( INHERIT: AUTO:0,PAGE_BREAK_BEFORE_AUTO ALWAYS:0,PAGE_BREAK_BEFORE_ALWAYS AVOID:0,PAGE_BREAK_BEFORE_AVOID LEFT:0,PAGE_BREAK_BEFORE_LEFT RIGHT:0,PAGE_BREAK_BEFORE_RIGHT IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse page_break_before
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_page_break_before(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_PAGE_BREAK_BEFORE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0, PAGE_BREAK_BEFORE_AUTO);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ALWAYS], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0, PAGE_BREAK_BEFORE_ALWAYS);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0, PAGE_BREAK_BEFORE_AVOID);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LEFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0, PAGE_BREAK_BEFORE_LEFT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIGHT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0, PAGE_BREAK_BEFORE_RIGHT);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_page_break_inside
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * page_break_inside:CSS_PROP_PAGE_BREAK_INSIDE IDENT:( INHERIT: AUTO:0,PAGE_BREAK_INSIDE_AUTO AVOID:0,PAGE_BREAK_INSIDE_AVOID IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse page_break_inside
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_page_break_inside(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_PAGE_BREAK_INSIDE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_INSIDE, 0, PAGE_BREAK_INSIDE_AUTO);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AVOID], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_INSIDE, 0, PAGE_BREAK_INSIDE_AVOID);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_pause_after
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * pause_after:CSS_PROP_PAUSE_AFTER IDENT:INHERIT LENGTH_UNIT:( UNIT_S:PAUSE_AFTER_SET DISALLOW:(unit&UNIT_TIME)==false&&(unit&UNIT_PCT)==false RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse pause_after
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_pause_after(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_PAUSE_AFTER);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_S, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if ((unit & UNIT_TIME) == false && (unit & UNIT_PCT) == false) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAUSE_AFTER, 0, PAUSE_AFTER_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_pause_before
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * pause_before:CSS_PROP_PAUSE_BEFORE IDENT:INHERIT LENGTH_UNIT:( UNIT_S:PAUSE_BEFORE_SET DISALLOW:(unit&UNIT_TIME)==false&&(unit&UNIT_PCT)==false RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse pause_before
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_pause_before(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_PAUSE_BEFORE);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_S, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if ((unit & UNIT_TIME) == false && (unit & UNIT_PCT) == false) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PAUSE_BEFORE, 0, PAUSE_BEFORE_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_pitch
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * pitch:CSS_PROP_PITCH IDENT:( INHERIT: X_LOW:0,PITCH_X_LOW LOW:0,PITCH_LOW MEDIUM:0,PITCH_MEDIUM HIGH:0,PITCH_HIGH X_HIGH:0,PITCH_X_HIGH IDENT:) LENGTH_UNIT:( UNIT_HZ:PITCH_FREQUENCY ALLOW:unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse pitch
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_pitch(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_PITCH);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[X_LOW], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0, PITCH_X_LOW);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[LOW], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0, PITCH_LOW);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[MEDIUM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0, PITCH_MEDIUM);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[HIGH], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0, PITCH_HIGH);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[X_HIGH], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0, PITCH_X_HIGH);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_HZ, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if ((unit & UNIT_FREQ) == false) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0, PITCH_FREQUENCY);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_pitch_range
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * pitch_range:CSS_PROP_PITCH_RANGE IDENT:INHERIT NUMBER:( false:PITCH_RANGE_SET RANGE:num<0||num>F_100 NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse pitch_range
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_pitch_range(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_PITCH_RANGE);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num<0 || num>F_100) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH_RANGE, 0, PITCH_RANGE_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_position
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * position:CSS_PROP_POSITION IDENT:( INHERIT: LIBCSS_STATIC:0,POSITION_STATIC RELATIVE:0,POSITION_RELATIVE ABSOLUTE:0,POSITION_ABSOLUTE FIXED:0,POSITION_FIXED IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse position
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_position(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_POSITION);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIBCSS_STATIC], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_POSITION, 0, POSITION_STATIC);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RELATIVE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_POSITION, 0, POSITION_RELATIVE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ABSOLUTE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_POSITION, 0, POSITION_ABSOLUTE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FIXED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_POSITION, 0, POSITION_FIXED);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_richness
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * richness:CSS_PROP_RICHNESS IDENT:INHERIT NUMBER:( false:RICHNESS_SET RANGE:num<0||num>F_100 NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse richness
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_richness(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_RICHNESS);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num<0 || num>F_100) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_RICHNESS, 0, RICHNESS_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_right
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * right:CSS_PROP_RIGHT WRAP:css__parse_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse right
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_right(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_side(c, vector, ctx, result, CSS_PROP_RIGHT);
}

/*********************************************************************************
autogenerated_side
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * side:op GENERIC: IDENT:( INHERIT: AUTO:0,BOTTOM_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:BOTTOM_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse side
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \param op	 Bytecode OpCode for CSS property to encode
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_side(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result, enum css_properties_e op)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, op);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, op, 0, BOTTOM_AUTO);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, op, 0, BOTTOM_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_speak
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * speak:CSS_PROP_SPEAK IDENT:( INHERIT: NORMAL:0,SPEAK_NORMAL NONE:0,SPEAK_NONE SPELL_OUT:0,SPEAK_SPELL_OUT IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse speak
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_speak(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_SPEAK);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK, 0, SPEAK_NORMAL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK, 0, SPEAK_NONE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[SPELL_OUT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK, 0, SPEAK_SPELL_OUT);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_speak_header
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * speak_header:CSS_PROP_SPEAK_HEADER IDENT:( INHERIT: ONCE:0,SPEAK_HEADER_ONCE ALWAYS:0,SPEAK_HEADER_ALWAYS IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse speak_header
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_speak_header(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_SPEAK_HEADER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ONCE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_HEADER, 0, SPEAK_HEADER_ONCE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[ALWAYS], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_HEADER, 0, SPEAK_HEADER_ALWAYS);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_speak_numeral
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * speak_numeral:CSS_PROP_SPEAK_NUMERAL IDENT:( INHERIT: DIGITS:0,SPEAK_NUMERAL_DIGITS CONTINUOUS:0,SPEAK_NUMERAL_CONTINUOUS IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse speak_numeral
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_speak_numeral(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_SPEAK_NUMERAL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[DIGITS], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_NUMERAL, 0, SPEAK_NUMERAL_DIGITS);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CONTINUOUS], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_NUMERAL, 0, SPEAK_NUMERAL_CONTINUOUS);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_speak_punctuation
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * speak_punctuation:CSS_PROP_SPEAK_PUNCTUATION IDENT:( INHERIT: CODE:0,SPEAK_PUNCTUATION_CODE NONE:0,SPEAK_PUNCTUATION_NONE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse speak_punctuation
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_speak_punctuation(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_SPEAK_PUNCTUATION);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CODE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_PUNCTUATION, 0, SPEAK_PUNCTUATION_CODE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_PUNCTUATION, 0, SPEAK_PUNCTUATION_NONE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_speech_rate
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * speech_rate:CSS_PROP_SPEECH_RATE IDENT:( INHERIT: X_SLOW:0,SPEECH_RATE_X_SLOW SLOW:0,SPEECH_RATE_SLOW MEDIUM:0,SPEECH_RATE_MEDIUM FAST:0,SPEECH_RATE_FAST X_FAST:0,SPEECH_RATE_X_FAST FASTER:0,SPEECH_RATE_FASTER SLOWER:0,SPEECH_RATE_SLOWER IDENT:) NUMBER:( false:SPEECH_RATE_SET RANGE:num<0 NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse speech_rate
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_speech_rate(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_SPEECH_RATE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[X_SLOW], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_X_SLOW);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[SLOW], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_SLOW);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[MEDIUM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_MEDIUM);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[FAST], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_FAST);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[X_FAST], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_X_FAST);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[FASTER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_FASTER);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[SLOWER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_SLOWER);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_stress
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * stress:CSS_PROP_STRESS IDENT:INHERIT NUMBER:( false:STRESS_SET RANGE:num<0||num>INTTOFIX(100) NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse stress
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_stress(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_STRESS);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num<0 || num>INTTOFIX(100)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_STRESS, 0, STRESS_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_table_layout
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * table_layout:CSS_PROP_TABLE_LAYOUT IDENT:( INHERIT: AUTO:0,TABLE_LAYOUT_AUTO FIXED:0,TABLE_LAYOUT_FIXED IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse table_layout
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_table_layout(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_TABLE_LAYOUT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TABLE_LAYOUT, 0, TABLE_LAYOUT_AUTO);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[FIXED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TABLE_LAYOUT, 0, TABLE_LAYOUT_FIXED);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_text_align
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * text_align:CSS_PROP_TEXT_ALIGN IDENT:( INHERIT: LEFT:0,TEXT_ALIGN_LEFT RIGHT:0,TEXT_ALIGN_RIGHT CENTER:0,TEXT_ALIGN_CENTER JUSTIFY:0,TEXT_ALIGN_JUSTIFY LIBCSS_LEFT:0,TEXT_ALIGN_LIBCSS_LEFT LIBCSS_CENTER:0,TEXT_ALIGN_LIBCSS_CENTER LIBCSS_RIGHT:0,TEXT_ALIGN_LIBCSS_RIGHT IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse text_align
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_text_align(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_TEXT_ALIGN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LEFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0, TEXT_ALIGN_LEFT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIGHT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0, TEXT_ALIGN_RIGHT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CENTER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0, TEXT_ALIGN_CENTER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[JUSTIFY], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0, TEXT_ALIGN_JUSTIFY);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIBCSS_LEFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0, TEXT_ALIGN_LIBCSS_LEFT);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIBCSS_CENTER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0, TEXT_ALIGN_LIBCSS_CENTER);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIBCSS_RIGHT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0, TEXT_ALIGN_LIBCSS_RIGHT);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_text_indent
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * text_indent:CSS_PROP_TEXT_INDENT IDENT:INHERIT LENGTH_UNIT:( UNIT_PX:TEXT_INDENT_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse text_indent
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_text_indent(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_TEXT_INDENT);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_INDENT, 0, TEXT_INDENT_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_text_transform
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * text_transform:CSS_PROP_TEXT_TRANSFORM IDENT:( INHERIT: CAPITALIZE:0,TEXT_TRANSFORM_CAPITALIZE UPPERCASE:0,TEXT_TRANSFORM_UPPERCASE LOWERCASE:0,TEXT_TRANSFORM_LOWERCASE NONE:0,TEXT_TRANSFORM_NONE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse text_transform
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_text_transform(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_TEXT_TRANSFORM);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[CAPITALIZE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_TRANSFORM, 0, TEXT_TRANSFORM_CAPITALIZE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[UPPERCASE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_TRANSFORM, 0, TEXT_TRANSFORM_UPPERCASE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[LOWERCASE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_TRANSFORM, 0, TEXT_TRANSFORM_LOWERCASE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_TRANSFORM, 0, TEXT_TRANSFORM_NONE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_top
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * top:CSS_PROP_TOP WRAP:css__parse_side
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse top
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_top(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    return css__parse_side(c, vector, ctx, result, CSS_PROP_TOP);
}

/*********************************************************************************
autogenerated_unicode_bidi
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * unicode_bidi:CSS_PROP_UNICODE_BIDI IDENT:( INHERIT: NORMAL:0,UNICODE_BIDI_NORMAL EMBED:0,UNICODE_BIDI_EMBED BIDI_OVERRIDE:0,UNICODE_BIDI_BIDI_OVERRIDE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse unicode_bidi
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_unicode_bidi(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_UNICODE_BIDI);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_UNICODE_BIDI, 0, UNICODE_BIDI_NORMAL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[EMBED], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_UNICODE_BIDI, 0, UNICODE_BIDI_EMBED);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[BIDI_OVERRIDE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_UNICODE_BIDI, 0, UNICODE_BIDI_BIDI_OVERRIDE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_vertical_align
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * vertical_align:CSS_PROP_VERTICAL_ALIGN IDENT:( INHERIT: BASELINE:0,VERTICAL_ALIGN_BASELINE SUB:0,VERTICAL_ALIGN_SUB SUPER:0,VERTICAL_ALIGN_SUPER TOP:0,VERTICAL_ALIGN_TOP TEXT_TOP:0,VERTICAL_ALIGN_TEXT_TOP MIDDLE:0,VERTICAL_ALIGN_MIDDLE BOTTOM:0,VERTICAL_ALIGN_BOTTOM TEXT_BOTTOM:0,VERTICAL_ALIGN_TEXT_BOTTOM IDENT:) LENGTH_UNIT:( UNIT_PX:VERTICAL_ALIGN_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse vertical_align
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_vertical_align(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_VERTICAL_ALIGN);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[BASELINE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_BASELINE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[SUB], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_SUB);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[SUPER], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_SUPER);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[TOP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_TOP);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[TEXT_TOP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_TEXT_TOP);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[MIDDLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_MIDDLE);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[BOTTOM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_BOTTOM);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[TEXT_BOTTOM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_TEXT_BOTTOM);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_visibility
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * visibility:CSS_PROP_VISIBILITY IDENT:( INHERIT: VISIBLE:0,VISIBILITY_VISIBLE HIDDEN:0,VISIBILITY_HIDDEN COLLAPSE:0,VISIBILITY_COLLAPSE IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse visibility
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_visibility(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_VISIBILITY);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[VISIBLE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VISIBILITY, 0, VISIBILITY_VISIBLE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[HIDDEN], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VISIBILITY, 0, VISIBILITY_HIDDEN);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[COLLAPSE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VISIBILITY, 0, VISIBILITY_COLLAPSE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_volume
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * volume:CSS_PROP_VOLUME IDENT:( INHERIT: SILENT:0,VOLUME_SILENT X_SOFT:0,VOLUME_X_SOFT SOFT:0,VOLUME_SOFT MEDIUM:0,VOLUME_MEDIUM LOUD:0,VOLUME_LOUD X_LOUD:0,VOLUME_X_LOUD IDENT:) NUMBER:( false:VOLUME_NUMBER RANGE:num<0||num>F_100 NUMBER:) LENGTH_UNIT:( UNIT_PX:VOLUME_DIMENSION ALLOW:unit&UNIT_PCT RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse volume
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_volume(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_VOLUME);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[SILENT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_SILENT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[X_SOFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_X_SOFT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[SOFT], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_SOFT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[MEDIUM], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_MEDIUM);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[LOUD], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_LOUD);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[X_LOUD], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_X_LOUD);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num<0 || num>F_100) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_NUMBER);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if ((unit & UNIT_PCT) == false) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_DIMENSION);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_white_space
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * white_space:CSS_PROP_WHITE_SPACE IDENT:( INHERIT: NORMAL:0,WHITE_SPACE_NORMAL PRE:0,WHITE_SPACE_PRE NOWRAP:0,WHITE_SPACE_NOWRAP PRE_WRAP:0,WHITE_SPACE_PRE_WRAP PRE_LINE:0,WHITE_SPACE_PRE_LINE  IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse white_space
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_white_space(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_WHITE_SPACE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0, WHITE_SPACE_NORMAL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[PRE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0, WHITE_SPACE_PRE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[NOWRAP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0, WHITE_SPACE_NOWRAP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[PRE_WRAP], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0, WHITE_SPACE_PRE_WRAP);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[PRE_LINE], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0, WHITE_SPACE_PRE_LINE);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_widows
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * widows:CSS_PROP_WIDOWS IDENT:INHERIT NUMBER:( true:WIDOWS_SET RANGE:num<0 NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse widows
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_widows(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_WIDOWS);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, true, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        if (num < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WIDOWS, 0, WIDOWS_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_width
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * width:CSS_PROP_WIDTH IDENT:( INHERIT: AUTO:0,WIDTH_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:WIDTH_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ RANGE:<0 LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse width
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_WIDTH);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WIDTH, 0, WIDTH_AUTO);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (length < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WIDTH, 0, WIDTH_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_word_spacing
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * word_spacing:CSS_PROP_WORD_SPACING IDENT:( INHERIT: NORMAL:0,WORD_SPACING_NORMAL IDENT:) LENGTH_UNIT:( UNIT_PX:WORD_SPACING_SET DISALLOW:unit&UNIT_ANGLE||unit&UNIT_TIME||unit&UNIT_FREQ||unit&UNIT_PCT LENGTH_UNIT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse word_spacing
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_word_spacing(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_WORD_SPACING);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[NORMAL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WORD_SPACING, 0, WORD_SPACING_NORMAL);
    }
    else {
        css_fixed length = 0;
        uint32_t unit = 0;
        *ctx = orig_ctx;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit & UNIT_ANGLE || unit & UNIT_TIME || unit & UNIT_FREQ || unit & UNIT_PCT) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WORD_SPACING, 0, WORD_SPACING_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result, 2, length, unit);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_writing_mode
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * writing_mode:CSS_PROP_WRITING_MODE IDENT:( INHERIT: HORIZONTAL_TB:0,WRITING_MODE_HORIZONTAL_TB VERTICAL_RL:0,WRITING_MODE_VERTICAL_RL VERTICAL_LR:0,WRITING_MODE_VERTICAL_LR IDENT:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse writing_mode
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_writing_mode(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_WRITING_MODE);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[HORIZONTAL_TB], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WRITING_MODE, 0, WRITING_MODE_HORIZONTAL_TB);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[VERTICAL_RL], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WRITING_MODE, 0, WRITING_MODE_VERTICAL_RL);
    }
    else if ((lwc_string_caseless_isequal(token->idata, c->strings[VERTICAL_LR], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_WRITING_MODE, 0, WRITING_MODE_VERTICAL_LR);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
autogenerated_z_index
*
*********************************************************************************/
/*
 * This file was generated by LibCSS gen_parser
 *
 * Generated from:
 *
 * z_index:CSS_PROP_Z_INDEX IDENT:( INHERIT: AUTO:0,Z_INDEX_AUTO IDENT:) NUMBER:( true:Z_INDEX_SET NUMBER:)
 *
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse z_index
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_z_index(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_Z_INDEX);
    }
    else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_Z_INDEX, 0, Z_INDEX_AUTO);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, true, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_Z_INDEX, 0, Z_INDEX_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
azimuth
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse azimuth
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  style to place resulting bytcode in
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_azimuth(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    uint8_t flags = 0;
    uint16_t value = 0;
    css_fixed length = 0;
    uint32_t unit = 0;
    bool match;

    /* angle | [ IDENT(left-side, far-left, left, center-left, center,
     *		   center-right, right, far-right, right-side) ||
     *	   IDENT(behind)
     *	 ]
     *	 | IDENT(leftwards, rightwards, inherit)
     */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        flags = FLAG_INHERIT;
    }
    else if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(token->idata, c->strings[LEFTWARDS],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        value = AZIMUTH_LEFTWARDS;
    }
    else if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(token->idata, c->strings[RIGHTWARDS],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        value = AZIMUTH_RIGHTWARDS;
    }
    else if (token->type == CSS_TOKEN_IDENT) {
        parserutils_vector_iterate(vector, ctx);

        /* Now, we may have one of the other keywords or behind,
         * potentially followed by behind or other keyword,
         * respectively */
        if ((lwc_string_caseless_isequal(
            token->idata, c->strings[LEFT_SIDE],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_LEFT_SIDE;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[FAR_LEFT],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_FAR_LEFT;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[LEFT],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_LEFT;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[CENTER_LEFT],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_CENTER_LEFT;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[CENTER],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_CENTER;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[CENTER_RIGHT],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_CENTER_RIGHT;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[RIGHT],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_RIGHT;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[FAR_RIGHT],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_FAR_RIGHT;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[RIGHT_SIDE],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_RIGHT_SIDE;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[BEHIND],
            &match) == lwc_error_ok && match)) {
            value = AZIMUTH_BEHIND;
        }
        else {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        consumeWhitespace(vector, ctx);

        /* Get potential following token */
        token = parserutils_vector_peek(vector, *ctx);

        if (token != NULL && token->type == CSS_TOKEN_IDENT &&
            value == AZIMUTH_BEHIND) {
            parserutils_vector_iterate(vector, ctx);

            if ((lwc_string_caseless_isequal(
                token->idata, c->strings[LEFT_SIDE],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_LEFT_SIDE;
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[FAR_LEFT],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_FAR_LEFT;
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[LEFT],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_LEFT;
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[CENTER_LEFT],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_CENTER_LEFT;
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[CENTER],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_CENTER;
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[CENTER_RIGHT],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_CENTER_RIGHT;
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[RIGHT],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_RIGHT;
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[FAR_RIGHT],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_FAR_RIGHT;
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[RIGHT_SIDE],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_RIGHT_SIDE;
            }
            else {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        else if (token != NULL && token->type == CSS_TOKEN_IDENT &&
            value != AZIMUTH_BEHIND) {
            parserutils_vector_iterate(vector, ctx);

            if ((lwc_string_caseless_isequal(
                token->idata, c->strings[BEHIND],
                &match) == lwc_error_ok && match)) {
                value |= AZIMUTH_BEHIND;
            }
            else {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        else if ((token == NULL || token->type != CSS_TOKEN_IDENT) &&
            value == AZIMUTH_BEHIND) {
            value |= AZIMUTH_CENTER;
        }
    }
    else {
        error = css__parse_unit_specifier(c, vector, ctx, UNIT_DEG,
            &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if ((unit & UNIT_ANGLE) == false) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        /* Valid angles lie between -360 and 360 degrees */
        if (unit == UNIT_DEG) {
            if ((length < -F_360) || (length > F_360)) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        else if (unit == UNIT_GRAD) {
            if ((length < -F_400) || (length > F_400)) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        else if (unit == UNIT_RAD) {
            if ((length < -F_2PI) || (length > F_2PI)) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }

        value = AZIMUTH_ANGLE;
    }

    error = css__stylesheet_style_appendOPV(result, CSS_PROP_AZIMUTH, flags, value);
    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    if (((flags & FLAG_INHERIT) == false) && (value == AZIMUTH_ANGLE)) {
        error = css__stylesheet_style_vappend(result, 2, length, unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }
    }

    return CSS_OK;
}

/*********************************************************************************
background
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse background
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_background(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_error error = CSS_OK;
    bool attachment = true;
    bool color = true;
    bool image = true;
    bool position = true;
    bool repeat = true;
    css_style* attachment_style;
    css_style* color_style;
    css_style* image_style;
    css_style* position_style;
    css_style* repeat_style;


    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_ATTACHMENT);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_COLOR);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_IMAGE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_POSITION);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_REPEAT);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* allocate styles */
    error = css__stylesheet_style_create(c->sheet, &attachment_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &color_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(attachment_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &image_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(attachment_style);
        css__stylesheet_style_destroy(color_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &position_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(attachment_style);
        css__stylesheet_style_destroy(color_style);
        css__stylesheet_style_destroy(image_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &repeat_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(attachment_style);
        css__stylesheet_style_destroy(color_style);
        css__stylesheet_style_destroy(image_style);
        css__stylesheet_style_destroy(position_style);
        return error;
    }

    /* Attempt to parse the various longhand properties */
    do {
        prev_ctx = *ctx;
        error = CSS_OK;

        if (is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_background_cleanup;
        }

        /* Try each property parser in turn, but only if we
         * haven't already got a value for this property.
         */
        if ((attachment) &&
            (error = css__parse_background_attachment(c, vector, ctx,
                attachment_style)) == CSS_OK) {
            attachment = false;
        }
        else if ((color) &&
            (error = css__parse_background_color(c, vector, ctx,
                color_style)) == CSS_OK) {
            color = false;
        }
        else if ((image) &&
            (error = css__parse_background_image(c, vector, ctx,
                image_style)) == CSS_OK) {
            image = false;
        }
        else if ((position) &&
            (error = css__parse_background_position(c, vector, ctx,
                position_style)) == CSS_OK) {
            position = false;
        }
        else if ((repeat) &&
            (error = css__parse_background_repeat(c, vector, ctx,
                repeat_style)) == CSS_OK) {
            repeat = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while (*ctx != prev_ctx && token != NULL);

    if (attachment) {
        error = css__stylesheet_style_appendOPV(attachment_style,
            CSS_PROP_BACKGROUND_ATTACHMENT, 0,
            BACKGROUND_ATTACHMENT_SCROLL);
        if (error != CSS_OK)
            goto css__parse_background_cleanup;
    }

    if (color) {
        error = css__stylesheet_style_appendOPV(color_style,
            CSS_PROP_BACKGROUND_COLOR, 0,
            BACKGROUND_COLOR_TRANSPARENT);
        if (error != CSS_OK)
            goto css__parse_background_cleanup;
    }

    if (image) {
        error = css__stylesheet_style_appendOPV(image_style,
            CSS_PROP_BACKGROUND_IMAGE,
            0, BACKGROUND_IMAGE_NONE);
        if (error != CSS_OK)
            goto css__parse_background_cleanup;
    }

    if (position) {
        error = css__stylesheet_style_appendOPV(position_style,
            CSS_PROP_BACKGROUND_POSITION,
            0, BACKGROUND_POSITION_HORZ_LEFT |
            BACKGROUND_POSITION_VERT_TOP);
        if (error != CSS_OK)
            goto css__parse_background_cleanup;
    }

    if (repeat) {
        error = css__stylesheet_style_appendOPV(repeat_style,
            CSS_PROP_BACKGROUND_REPEAT,
            0, BACKGROUND_REPEAT_REPEAT);
        if (error != CSS_OK)
            goto css__parse_background_cleanup;
    }

    error = css__stylesheet_merge_style(result, attachment_style);
    if (error != CSS_OK)
        goto css__parse_background_cleanup;

    error = css__stylesheet_merge_style(result, color_style);
    if (error != CSS_OK)
        goto css__parse_background_cleanup;

    error = css__stylesheet_merge_style(result, image_style);
    if (error != CSS_OK)
        goto css__parse_background_cleanup;

    error = css__stylesheet_merge_style(result, position_style);
    if (error != CSS_OK)
        goto css__parse_background_cleanup;

    error = css__stylesheet_merge_style(result, repeat_style);

css__parse_background_cleanup:
    css__stylesheet_style_destroy(attachment_style);
    css__stylesheet_style_destroy(color_style);
    css__stylesheet_style_destroy(image_style);
    css__stylesheet_style_destroy(position_style);
    css__stylesheet_style_destroy(repeat_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;


}







/*********************************************************************************
background_position
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse background-position
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_background_position(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    uint8_t flags = 0;
    uint16_t value[2] = { 0 };
    css_fixed length[2] = { 0 };
    uint32_t unit[2] = { 0 };
    bool match;

    /* [length | percentage | IDENT(left, right, top, bottom, center)]{1,2}
     * | IDENT(inherit) */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        flags = FLAG_INHERIT;
    }
    else {
        int i;

        for (i = 0; i < 2; i++) {
            token = parserutils_vector_peek(vector, *ctx);
            if (token == NULL)
                break;

            if (token->type == CSS_TOKEN_IDENT) {
                if ((lwc_string_caseless_isequal(
                    token->idata, c->strings[LEFT],
                    &match) == lwc_error_ok &&
                    match)) {
                    value[i] =
                        BACKGROUND_POSITION_HORZ_LEFT;
                }
                else if ((lwc_string_caseless_isequal(
                    token->idata, c->strings[RIGHT],
                    &match) == lwc_error_ok &&
                    match)) {
                    value[i] =
                        BACKGROUND_POSITION_HORZ_RIGHT;
                }
                else if ((lwc_string_caseless_isequal(
                    token->idata, c->strings[TOP],
                    &match) == lwc_error_ok &&
                    match)) {
                    value[i] = BACKGROUND_POSITION_VERT_TOP;
                }
                else if ((lwc_string_caseless_isequal(
                    token->idata,
                    c->strings[BOTTOM],
                    &match) == lwc_error_ok &&
                    match)) {
                    value[i] =
                        BACKGROUND_POSITION_VERT_BOTTOM;
                }
                else if ((lwc_string_caseless_isequal(
                    token->idata,
                    c->strings[CENTER],
                    &match) == lwc_error_ok &&
                    match)) {
                    /* We'll fix this up later */
                    value[i] =
                        BACKGROUND_POSITION_VERT_CENTER;
                }
                else if (i == 1) {
                    /* Second pass, so ignore this one */
                    break;
                }
                else {
                    /* First pass, so invalid */
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                parserutils_vector_iterate(vector, ctx);
            }
            else if (token->type == CSS_TOKEN_DIMENSION ||
                token->type == CSS_TOKEN_NUMBER ||
                token->type == CSS_TOKEN_PERCENTAGE) {
                error = css__parse_unit_specifier(c, vector, ctx,
                    UNIT_PX, &length[i], &unit[i]);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                if (unit[i] & UNIT_ANGLE ||
                    unit[i] & UNIT_TIME ||
                    unit[i] & UNIT_FREQ) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                /* We'll fix this up later, too */
                value[i] = BACKGROUND_POSITION_VERT_SET;
            }
            else {
                if (i == 1) {
                    /* Second pass, so ignore */
                    break;
                }
                else {
                    /* First pass, so invalid */
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }

            consumeWhitespace(vector, ctx);
        }

        assert(i != 0);

        /* Now, sort out the mess we've got */
        if (i == 1) {
            assert(BACKGROUND_POSITION_VERT_CENTER ==
                BACKGROUND_POSITION_HORZ_CENTER);

            /* Only one value, so the other is center */
            switch (value[0]) {
            case BACKGROUND_POSITION_HORZ_LEFT:
            case BACKGROUND_POSITION_HORZ_RIGHT:
            case BACKGROUND_POSITION_VERT_CENTER:
            case BACKGROUND_POSITION_VERT_TOP:
            case BACKGROUND_POSITION_VERT_BOTTOM:
                break;
            case BACKGROUND_POSITION_VERT_SET:
                value[0] = BACKGROUND_POSITION_HORZ_SET;
                break;
            }

            value[1] = BACKGROUND_POSITION_VERT_CENTER;
        }
        else if (value[0] != BACKGROUND_POSITION_VERT_SET &&
            value[1] != BACKGROUND_POSITION_VERT_SET) {
            /* Two keywords. Verify the axes differ */
            if (((value[0] & 0xf) != 0 && (value[1] & 0xf) != 0) ||
                ((value[0] & 0xf0) != 0 &&
                    (value[1] & 0xf0) != 0)) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        else {
            /* One or two non-keywords. First is horizontal */
            if (value[0] == BACKGROUND_POSITION_VERT_SET)
                value[0] = BACKGROUND_POSITION_HORZ_SET;

            /* Verify the axes differ */
            if (((value[0] & 0xf) != 0 && (value[1] & 0xf) != 0) ||
                ((value[0] & 0xf0) != 0 &&
                    (value[1] & 0xf0) != 0)) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
    }

    error = css__stylesheet_style_appendOPV(result,
        CSS_PROP_BACKGROUND_POSITION,
        flags,
        value[0] | value[1]);
    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    if ((flags & FLAG_INHERIT) == false) {
        if (value[0] == BACKGROUND_POSITION_HORZ_SET) {
            error = css__stylesheet_style_append(result, length[0]);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            error = css__stylesheet_style_append(result, unit[0]);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }
        }
        if (value[1] == BACKGROUND_POSITION_VERT_SET) {
            error = css__stylesheet_style_append(result, length[1]);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            error = css__stylesheet_style_append(result, unit[1]);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }
        }
    }

    return CSS_OK;
}

/*********************************************************************************
border
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;

    error = css__parse_border_side(c, vector, ctx, result, BORDER_SIDE_TOP);
    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    *ctx = orig_ctx;
    error = css__parse_border_side(c, vector, ctx, result, BORDER_SIDE_RIGHT);
    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    *ctx = orig_ctx;
    error = css__parse_border_side(c, vector, ctx, result, BORDER_SIDE_BOTTOM);
    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    *ctx = orig_ctx;
    error = css__parse_border_side(c, vector, ctx, result, BORDER_SIDE_LEFT);
    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;

}

/*********************************************************************************
border_color
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border-color shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_color(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    uint16_t side_val[4];
    uint32_t side_color[4];
    uint32_t side_count = 0;
    css_error error;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_TOP_COLOR);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_RIGHT_COLOR);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_BOTTOM_COLOR);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_LEFT_COLOR);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Attempt to parse up to 4 colours */
    do {
        prev_ctx = *ctx;

        if ((token != NULL) && is_css_inherit(c, token)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__parse_colour_specifier(c, vector, ctx, &side_val[side_count], &side_color[side_count]);
        if (error == CSS_OK) {
            side_count++;

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while ((*ctx != prev_ctx) && (token != NULL) && (side_count < 4));


#define SIDE_APPEND(OP,NUM)								\
	error = css__stylesheet_style_appendOPV(result, (OP), 0, side_val[(NUM)]);	\
	if (error != CSS_OK)								\
		break;									\
	if (side_val[(NUM)] == BORDER_COLOR_SET)					\
		error = css__stylesheet_style_append(result, side_color[(NUM)]);		\
	if (error != CSS_OK)								\
		break;

    switch (side_count) {
    case 1:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_COLOR, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_COLOR, 0);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_COLOR, 0);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_COLOR, 0);
        break;
    case 2:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_COLOR, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_COLOR, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_COLOR, 0);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_COLOR, 1);
        break;
    case 3:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_COLOR, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_COLOR, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_COLOR, 2);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_COLOR, 1);
        break;
    case 4:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_COLOR, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_COLOR, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_COLOR, 2);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_COLOR, 3);
        break;
    default:
        error = CSS_INVALID;
        break;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
border_radius
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2017 ZhuYaDong <aeix@foxmail.com>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border-radius shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_radius(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    /* we don't support '/' split value of border-radius */
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    uint16_t val[4];
    css_fixed radius[4];
    uint32_t unit[4];
    uint32_t count = 0;
    bool match;
    css_error error;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_TOP_LEFT_RADIUS);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_TOP_RIGHT_RADIUS);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Attempt to parse up to 4 radius */
    do {
        prev_ctx = *ctx;

        if ((token != NULL) && (token->type == CSS_TOKEN_IDENT || is_css_inherit(c, token))) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        val[count] = BORDER_RADIUS_SET;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &radius[count], &unit[count]);
        if (error == CSS_OK) {
            if (unit[count] & UNIT_ANGLE ||
                unit[count] & UNIT_TIME ||
                unit[count] & UNIT_FREQ) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            ++count;

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            token = NULL;
        }
    } while ((*ctx != prev_ctx) && (token != NULL) && (count < 4));

#define RADIUS_APPEND(OP,NUM) \
    error = css__stylesheet_style_appendOPV(result, (OP), 0, val[(NUM)]); \
    if (error != CSS_OK)  \
      break;  \
    if (val[(NUM)] == BORDER_RADIUS_SET) {  \
      error = css__stylesheet_style_append(result, radius[(NUM)]);  \
      if (error != CSS_OK)  \
        break;  \
      error = css__stylesheet_style_append(result, unit[(NUM)]);  \
      if (error != CSS_OK)  \
        break;  \
    }

    switch (count) {
    case 1:
        RADIUS_APPEND(CSS_PROP_BORDER_TOP_LEFT_RADIUS, 0);
        RADIUS_APPEND(CSS_PROP_BORDER_TOP_RIGHT_RADIUS, 0);
        RADIUS_APPEND(CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS, 0);
        RADIUS_APPEND(CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS, 0);
        break;
    case 2:
        RADIUS_APPEND(CSS_PROP_BORDER_TOP_LEFT_RADIUS, 0);
        RADIUS_APPEND(CSS_PROP_BORDER_TOP_RIGHT_RADIUS, 1);
        RADIUS_APPEND(CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS, 0);
        RADIUS_APPEND(CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS, 1);
        break;
    case 3:
        RADIUS_APPEND(CSS_PROP_BORDER_TOP_LEFT_RADIUS, 0);
        RADIUS_APPEND(CSS_PROP_BORDER_TOP_RIGHT_RADIUS, 1);
        RADIUS_APPEND(CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS, 2);
        RADIUS_APPEND(CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS, 1);
        break;
    case 4:
        RADIUS_APPEND(CSS_PROP_BORDER_TOP_LEFT_RADIUS, 0);
        RADIUS_APPEND(CSS_PROP_BORDER_TOP_RIGHT_RADIUS, 1);
        RADIUS_APPEND(CSS_PROP_BORDER_BOTTOM_RIGHT_RADIUS, 2);
        RADIUS_APPEND(CSS_PROP_BORDER_BOTTOM_LEFT_RADIUS, 3);
        break;
    default:
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
border_spacing
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border-spacing
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_spacing(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    css_fixed length[2] = { 0 };
    uint32_t unit[2] = { 0 };
    bool match;

    /* length length? | IDENT(inherit) */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        /* inherit */
        error = css__stylesheet_style_appendOPV(result,
            CSS_PROP_BORDER_SPACING,
            FLAG_INHERIT,
            0);
    }
    else {
        int num_lengths = 0;

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX,
            &length[0], &unit[0]);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if (unit[0] & UNIT_ANGLE || unit[0] & UNIT_TIME ||
            unit[0] & UNIT_FREQ || unit[0] & UNIT_PCT) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        num_lengths = 1;

        consumeWhitespace(vector, ctx);

        token = parserutils_vector_peek(vector, *ctx);
        if (token != NULL) {
            /* Attempt second length, ignoring errors.
             * The core !important parser will ensure
             * any remaining junk is thrown out.
             * Ctx will be preserved on error, as usual
             */
            error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX,
                &length[1], &unit[1]);
            if (error == CSS_OK) {
                if (unit[1] & UNIT_ANGLE ||
                    unit[1] & UNIT_TIME ||
                    unit[1] & UNIT_FREQ ||
                    unit[1] & UNIT_PCT) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                num_lengths = 2;
            }
        }

        if (num_lengths == 1) {
            /* Only one length specified. Use for both axes. */
            length[1] = length[0];
            unit[1] = unit[0];
        }

        /* Lengths must not be negative */
        if (length[0] < 0 || length[1] < 0) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__stylesheet_style_appendOPV(result,
            CSS_PROP_BORDER_SPACING,
            0,
            BORDER_SPACING_SET);

        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_vappend(result,
            4,
            length[0],
            unit[0],
            length[1],
            unit[1]);

    }

    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    return CSS_OK;
}

/*********************************************************************************
border_style
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border-style shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    uint16_t side_val[4];
    uint32_t side_count = 0;
    bool match;
    css_error error;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_TOP_STYLE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_RIGHT_STYLE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_BOTTOM_STYLE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_LEFT_STYLE);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Attempt to parse up to 4 styles */
    do {
        prev_ctx = *ctx;

        if ((token != NULL) && is_css_inherit(c, token)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (token->type != CSS_TOKEN_IDENT)
            break;

        if ((lwc_string_caseless_isequal(token->idata, c->strings[NONE], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_NONE;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[HIDDEN], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_HIDDEN;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[DOTTED], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_DOTTED;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[DASHED], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_DASHED;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[SOLID], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_SOLID;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[LIBCSS_DOUBLE], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_DOUBLE;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[GROOVE], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_GROOVE;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[RIDGE], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_RIDGE;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[INSET], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_INSET;
        }
        else if ((lwc_string_caseless_isequal(token->idata, c->strings[OUTSET], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_STYLE_OUTSET;
        }
        else {
            break;
        }

        side_count++;

        parserutils_vector_iterate(vector, ctx);

        consumeWhitespace(vector, ctx);

        token = parserutils_vector_peek(vector, *ctx);
    } while ((*ctx != prev_ctx) && (token != NULL) && (side_count < 4));


#define SIDE_APPEND(OP,NUM)								\
	error = css__stylesheet_style_appendOPV(result, (OP), 0, side_val[(NUM)]);	\
	if (error != CSS_OK)								\
		break

    switch (side_count) {
    case 1:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_STYLE, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_STYLE, 0);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_STYLE, 0);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_STYLE, 0);
        break;
    case 2:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_STYLE, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_STYLE, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_STYLE, 0);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_STYLE, 1);
        break;
    case 3:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_STYLE, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_STYLE, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_STYLE, 2);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_STYLE, 1);
        break;
    case 4:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_STYLE, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_STYLE, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_STYLE, 2);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_STYLE, 3);
        break;

    default:
        error = CSS_INVALID;
        break;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
border_width
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse border-width shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_border_width(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    uint16_t side_val[4];
    css_fixed side_length[4];
    uint32_t side_unit[4];
    uint32_t side_count = 0;
    bool match;
    css_error error;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_TOP_WIDTH);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_RIGHT_WIDTH);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_BOTTOM_WIDTH);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_LEFT_WIDTH);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Attempt to parse up to 4 widths */
    do {
        prev_ctx = *ctx;

        if ((token != NULL) && is_css_inherit(c, token)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[THIN], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_WIDTH_THIN;
            parserutils_vector_iterate(vector, ctx);
            error = CSS_OK;
        }
        else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[MEDIUM], &match) == lwc_error_ok && match)) {
            side_val[side_count] = BORDER_WIDTH_MEDIUM;
            parserutils_vector_iterate(vector, ctx);
            error = CSS_OK;
        }
        else if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[THICK], &match) == lwc_error_ok && match)) {
            parserutils_vector_iterate(vector, ctx);
            error = CSS_OK;
            side_val[side_count] = BORDER_WIDTH_THICK;
        }
        else {
            side_val[side_count] = BORDER_WIDTH_SET;

            error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &side_length[side_count], &side_unit[side_count]);
            if (error == CSS_OK) {
                if (side_unit[side_count] == UNIT_PCT ||
                    side_unit[side_count] & UNIT_ANGLE ||
                    side_unit[side_count] & UNIT_TIME ||
                    side_unit[side_count] & UNIT_FREQ) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                if (side_length[side_count] < 0) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
        }

        if (error == CSS_OK) {
            side_count++;

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while ((*ctx != prev_ctx) && (token != NULL) && (side_count < 4));


#define SIDE_APPEND(OP,NUM)								\
	error = css__stylesheet_style_appendOPV(result, (OP), 0, side_val[(NUM)]);	\
	if (error != CSS_OK)								\
		break;									\
	if (side_val[(NUM)] == BORDER_WIDTH_SET) {					\
		error = css__stylesheet_style_append(result, side_length[(NUM)]);	\
		if (error != CSS_OK)							\
			break;								\
		error = css__stylesheet_style_append(result, side_unit[(NUM)]);		\
		if (error != CSS_OK)							\
			break;								\
	}

    switch (side_count) {
    case 1:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_WIDTH, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_WIDTH, 0);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_WIDTH, 0);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_WIDTH, 0);
        break;
    case 2:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_WIDTH, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_WIDTH, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_WIDTH, 0);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_WIDTH, 1);
        break;
    case 3:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_WIDTH, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_WIDTH, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_WIDTH, 2);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_WIDTH, 1);
        break;
    case 4:
        SIDE_APPEND(CSS_PROP_BORDER_TOP_WIDTH, 0);
        SIDE_APPEND(CSS_PROP_BORDER_RIGHT_WIDTH, 1);
        SIDE_APPEND(CSS_PROP_BORDER_BOTTOM_WIDTH, 2);
        SIDE_APPEND(CSS_PROP_BORDER_LEFT_WIDTH, 3);
        break;
    default:
        error = CSS_INVALID;
        break;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
clip
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse clip
  *
  * \param c       Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx     Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *         CSS_NOMEM on memory exhaustion,
  *         CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *                 If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_clip(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    int num_lengths = 0;
    css_fixed length[4] = { 0 };
    uint32_t unit[4] = { 0 };
    bool match;

    /* FUNCTION(rect) [ [ IDENT(auto) | length ] CHAR(,)? ]{3}
     *                [ IDENT(auto) | length ] CHAR{)} |
     * IDENT(auto, inherit) */
    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result,
            CSS_PROP_CLIP,
            FLAG_INHERIT,
            0);
    }
    else if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[AUTO],
            &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result,
            CSS_PROP_CLIP,
            0,
            CLIP_AUTO);
    }
    else if ((token->type == CSS_TOKEN_FUNCTION) &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[RECT],
            &match) == lwc_error_ok && match)) {
        int i;
        uint16_t value = CLIP_SHAPE_RECT;

        for (i = 0; i < 4; i++) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
            if (token == NULL) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            if (token->type == CSS_TOKEN_IDENT) {
                /* Slightly magical way of generating the auto
                 * values. These are bits 3-6 of the value. */
                if ((lwc_string_caseless_isequal(
                    token->idata, c->strings[AUTO],
                    &match) == lwc_error_ok &&
                    match))
                    value |= 1 << (i + 3);
                else {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                parserutils_vector_iterate(vector, ctx);
            }
            else {
                error = css__parse_unit_specifier(c, vector, ctx,
                    UNIT_PX,
                    &length[num_lengths],
                    &unit[num_lengths]);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                if (unit[num_lengths] & UNIT_ANGLE ||
                    unit[num_lengths] & UNIT_TIME ||
                    unit[num_lengths] & UNIT_FREQ ||
                    unit[num_lengths] & UNIT_PCT) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                num_lengths++;
            }

            consumeWhitespace(vector, ctx);

            /* Consume optional comma after first 3 parameters */
            if (i < 3) {
                token = parserutils_vector_peek(vector, *ctx);
                if (token == NULL) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                if (tokenIsChar(token, ','))
                    parserutils_vector_iterate(vector, ctx);
            }
        }

        consumeWhitespace(vector, ctx);

        /* Finally, consume closing parenthesis */
        token = parserutils_vector_iterate(vector, ctx);
        if (token == NULL || tokenIsChar(token, ')') == false) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        /* output bytecode */
        error = css__stylesheet_style_appendOPV(result,
            CSS_PROP_CLIP,
            0,
            value);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        for (i = 0; i < num_lengths; i++) {
            error = css__stylesheet_style_vappend(result,
                2,
                length[i],
                unit[i]);
            if (error != CSS_OK)
                break;
        }


    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK) {
        *ctx = orig_ctx;
    }

    return error;
}

/*********************************************************************************
columns
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2012 Michael Drake <tlsa@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse columns shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_columns(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_error error = CSS_OK;
    bool width = true;
    bool count = true;
    css_style* width_style;
    css_style* count_style;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result,
            CSS_PROP_COLUMN_WIDTH);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result,
            CSS_PROP_COLUMN_COUNT);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Allocate for styles */
    error = css__stylesheet_style_create(c->sheet, &width_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &count_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(width_style);
        return error;
    }

    /* Attempt to parse the various longhand properties */
    do {
        prev_ctx = *ctx;
        error = CSS_OK;

        if (is_css_inherit(c, token)) {
            /* Can't have another inherit */
            error = CSS_INVALID;
            goto css__parse_columns_cleanup;
        }

        /* Try each property parser in turn, but only if we
         * haven't already got a value for this property.
         */
        if ((width) &&
            (error = css__parse_column_width(c, vector, ctx,
                width_style)) == CSS_OK) {
            width = false;
        }
        else if ((count) &&
            (error = css__parse_column_count(c, vector, ctx,
                count_style)) == CSS_OK) {
            count = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while (*ctx != prev_ctx && token != NULL);

    /* Set unset properties to initial values */
    if (width) {
        error = css__stylesheet_style_appendOPV(width_style,
            CSS_PROP_COLUMN_WIDTH, 0,
            COLUMN_WIDTH_AUTO);
        if (error != CSS_OK)
            goto css__parse_columns_cleanup;
    }

    if (count) {
        error = css__stylesheet_style_appendOPV(count_style,
            CSS_PROP_COLUMN_COUNT, 0,
            COLUMN_COUNT_AUTO);
        if (error != CSS_OK)
            goto css__parse_columns_cleanup;
    }

    /* Merge styles into the result */
    error = css__stylesheet_merge_style(result, width_style);
    if (error != CSS_OK)
        goto css__parse_columns_cleanup;

    error = css__stylesheet_merge_style(result, count_style);


css__parse_columns_cleanup:
    css__stylesheet_style_destroy(width_style);
    css__stylesheet_style_destroy(count_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
column_rule
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2012 Michael Drake <tlsa@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse column-rule shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_column_rule(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_error error;
    bool color = true;
    bool style = true;
    bool width = true;
    css_style* color_style;
    css_style* style_style;
    css_style* width_style;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result,
            CSS_PROP_COLUMN_RULE_COLOR);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result,
            CSS_PROP_COLUMN_RULE_STYLE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result,
            CSS_PROP_COLUMN_RULE_WIDTH);

        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Allocate for styles */
    error = css__stylesheet_style_create(c->sheet, &color_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &style_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(color_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &width_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(color_style);
        css__stylesheet_style_destroy(style_style);
        return error;
    }

    /* Attempt to parse the various longhand properties */
    do {
        prev_ctx = *ctx;
        error = CSS_OK;

        /* Ensure that we're not about to parse another inherit */
        token = parserutils_vector_peek(vector, *ctx);
        if (token != NULL && is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_column_rule_cleanup;
        }

        if ((color) &&
            (error = css__parse_column_rule_color(c, vector,
                ctx, color_style)) == CSS_OK) {
            color = false;
        }
        else if ((style) &&
            (error = css__parse_column_rule_style(c, vector,
                ctx, style_style)) == CSS_OK) {
            style = false;
        }
        else if ((width) &&
            (error = css__parse_column_rule_width(c, vector,
                ctx, width_style)) == CSS_OK) {
            width = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while (*ctx != prev_ctx && token != NULL);

    /* Set unset properties to initial values */
    if (color) {
        error = css__stylesheet_style_appendOPV(color_style,
            CSS_PROP_COLUMN_RULE_COLOR, 0,
            COLUMN_RULE_COLOR_SET);
        if (error != CSS_OK)
            goto css__parse_column_rule_cleanup;

        /** TODO: initial colour should be the UA-defined initial
         *        value of the "color" property, not "0" */
        error = css__stylesheet_style_append(color_style, 0x00000000);
        if (error != CSS_OK)
            goto css__parse_column_rule_cleanup;
    }

    if (style) {
        error = css__stylesheet_style_appendOPV(style_style,
            CSS_PROP_COLUMN_RULE_STYLE, 0,
            COLUMN_RULE_STYLE_NONE);
        if (error != CSS_OK)
            goto css__parse_column_rule_cleanup;
    }

    if (width) {
        error = css__stylesheet_style_appendOPV(width_style,
            CSS_PROP_COLUMN_RULE_WIDTH, 0,
            COLUMN_RULE_WIDTH_MEDIUM);
        if (error != CSS_OK)
            goto css__parse_column_rule_cleanup;
    }

    /* Merge styles into the result */
    error = css__stylesheet_merge_style(result, color_style);
    if (error != CSS_OK)
        goto css__parse_column_rule_cleanup;

    error = css__stylesheet_merge_style(result, style_style);
    if (error != CSS_OK)
        goto css__parse_column_rule_cleanup;

    error = css__stylesheet_merge_style(result, width_style);


css__parse_column_rule_cleanup:

    css__stylesheet_style_destroy(width_style);
    css__stylesheet_style_destroy(style_style);
    css__stylesheet_style_destroy(color_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
content
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"



 /**
  * Parse content
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_content(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    /* IDENT(normal, none, inherit) | [ ... ]+ */
    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }


    if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(token->idata,
            c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_CONTENT);
    }
    else if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(token->idata,
            c->strings[NORMAL],
            &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CONTENT, 0, CONTENT_NORMAL);
    }
    else if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(token->idata,
            c->strings[NONE],
            &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_CONTENT, 0, CONTENT_NONE);
    }
    else {

        /* Macro to output the value marker, awkward because we need to check
         * first to determine how the value is constructed.
         */
#define CSS_APPEND(CSSVAL) css__stylesheet_style_append(result, first?buildOPV(CSS_PROP_CONTENT, 0, CSSVAL):CSSVAL)

        bool first = true;
        int prev_ctx = orig_ctx;

        /* [
         *   IDENT(open-quote, close-quote, no-open-quote,
         *         no-close-quote) |
         *   STRING |
         *   URI |
         *   FUNCTION(attr) IDENT ')' |
         *   FUNCTION(counter) IDENT IDENT? ')' |
         *   FUNCTION(counters) IDENT STRING IDENT? ')'
         * ]+
         */

        while (token != NULL) {
            if ((token->type == CSS_TOKEN_IDENT) &&
                (lwc_string_caseless_isequal(
                    token->idata, c->strings[OPEN_QUOTE],
                    &match) == lwc_error_ok && match)) {

                error = CSS_APPEND(CONTENT_OPEN_QUOTE);

            }
            else if (token->type == CSS_TOKEN_IDENT &&
                (lwc_string_caseless_isequal(
                    token->idata, c->strings[CLOSE_QUOTE],
                    &match) == lwc_error_ok && match)) {

                error = CSS_APPEND(CONTENT_CLOSE_QUOTE);
            }
            else if (token->type == CSS_TOKEN_IDENT &&
                (lwc_string_caseless_isequal(
                    token->idata, c->strings[NO_OPEN_QUOTE],
                    &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CONTENT_NO_OPEN_QUOTE);
            }
            else if (token->type == CSS_TOKEN_IDENT &&
                (lwc_string_caseless_isequal(
                    token->idata, c->strings[NO_CLOSE_QUOTE],
                    &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CONTENT_NO_CLOSE_QUOTE);
            }
            else if (token->type == CSS_TOKEN_STRING) {
                uint32_t snumber;

                error = css__stylesheet_string_add(c->sheet, lwc_string_ref(token->idata), &snumber);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = CSS_APPEND(CONTENT_STRING);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = css__stylesheet_style_append(result, snumber);
            }
            else if (token->type == CSS_TOKEN_URI) {
                lwc_string* uri;
                uint32_t uri_snumber;

                error = c->sheet->resolve(c->sheet->resolve_pw,
                    c->sheet->url,
                    token->idata,
                    &uri);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = css__stylesheet_string_add(c->sheet,
                    uri,
                    &uri_snumber);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = CSS_APPEND(CONTENT_URI);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = css__stylesheet_style_append(result, uri_snumber);
            }
            else if (token->type == CSS_TOKEN_FUNCTION &&
                (lwc_string_caseless_isequal(
                    token->idata, c->strings[ATTR],
                    &match) == lwc_error_ok && match)) {
                uint32_t snumber;

                consumeWhitespace(vector, ctx);

                /* Expect IDENT */
                token = parserutils_vector_iterate(vector, ctx);
                if (token == NULL || token->type != CSS_TOKEN_IDENT) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                error = css__stylesheet_string_add(c->sheet, lwc_string_ref(token->idata), &snumber);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = CSS_APPEND(CONTENT_ATTR);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = css__stylesheet_style_append(result, snumber);

                consumeWhitespace(vector, ctx);

                /* Expect ')' */
                token = parserutils_vector_iterate(vector, ctx);
                if (token == NULL || tokenIsChar(token, ')') == false) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
            else if (token->type == CSS_TOKEN_FUNCTION &&
                (lwc_string_caseless_isequal(
                    token->idata, c->strings[COUNTER],
                    &match) == lwc_error_ok && match)) {
                lwc_string* name;
                uint32_t snumber;
                uint32_t opv;

                opv = CONTENT_COUNTER;

                consumeWhitespace(vector, ctx);

                /* Expect IDENT */
                token = parserutils_vector_iterate(vector, ctx);
                if (token == NULL || token->type != CSS_TOKEN_IDENT) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                name = token->idata;

                consumeWhitespace(vector, ctx);

                /* Possible ',' */
                token = parserutils_vector_peek(vector, *ctx);
                if (token == NULL ||
                    (tokenIsChar(token, ',') == false &&
                        tokenIsChar(token, ')') == false)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                if (tokenIsChar(token, ',')) {
                    uint16_t v;

                    parserutils_vector_iterate(vector, ctx);

                    consumeWhitespace(vector, ctx);

                    /* Expect IDENT */
                    token = parserutils_vector_peek(vector, *ctx);
                    if (token == NULL || token->type !=
                        CSS_TOKEN_IDENT) {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    error = css__parse_list_style_type_value(c, token, &v);
                    if (error != CSS_OK) {
                        *ctx = orig_ctx;
                        return error;
                    }

                    opv |= v << CONTENT_COUNTER_STYLE_SHIFT;

                    parserutils_vector_iterate(vector, ctx);

                    consumeWhitespace(vector, ctx);
                }
                else {
                    opv |= LIST_STYLE_TYPE_DECIMAL <<
                        CONTENT_COUNTER_STYLE_SHIFT;
                }

                /* Expect ')' */
                token = parserutils_vector_iterate(vector, ctx);
                if (token == NULL || tokenIsChar(token, ')') == false) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }


                error = css__stylesheet_string_add(c->sheet, lwc_string_ref(name), &snumber);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = CSS_APPEND(opv);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = css__stylesheet_style_append(result, snumber);
            }
            else if (token->type == CSS_TOKEN_FUNCTION &&
                (lwc_string_caseless_isequal(
                    token->idata, c->strings[COUNTERS],
                    &match) == lwc_error_ok && match)) {
                lwc_string* name;
                lwc_string* sep;
                uint32_t name_snumber;
                uint32_t sep_snumber;
                uint32_t opv;

                opv = CONTENT_COUNTERS;

                consumeWhitespace(vector, ctx);

                /* Expect IDENT */
                token = parserutils_vector_iterate(vector, ctx);
                if (token == NULL || token->type != CSS_TOKEN_IDENT) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                name = token->idata;

                consumeWhitespace(vector, ctx);

                /* Expect ',' */
                token = parserutils_vector_iterate(vector, ctx);
                if (token == NULL || tokenIsChar(token, ',') == false) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                consumeWhitespace(vector, ctx);

                /* Expect STRING */
                token = parserutils_vector_iterate(vector, ctx);
                if (token == NULL || token->type != CSS_TOKEN_STRING) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                sep = token->idata;

                consumeWhitespace(vector, ctx);

                /* Possible ',' */
                token = parserutils_vector_peek(vector, *ctx);
                if (token == NULL ||
                    (tokenIsChar(token, ',') == false &&
                        tokenIsChar(token, ')') == false)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                if (tokenIsChar(token, ',')) {
                    uint16_t v;

                    parserutils_vector_iterate(vector, ctx);

                    consumeWhitespace(vector, ctx);

                    /* Expect IDENT */
                    token = parserutils_vector_peek(vector, *ctx);
                    if (token == NULL || token->type !=
                        CSS_TOKEN_IDENT) {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    error = css__parse_list_style_type_value(c,
                        token, &v);
                    if (error != CSS_OK) {
                        *ctx = orig_ctx;
                        return error;
                    }

                    opv |= v << CONTENT_COUNTERS_STYLE_SHIFT;

                    parserutils_vector_iterate(vector, ctx);

                    consumeWhitespace(vector, ctx);
                }
                else {
                    opv |= LIST_STYLE_TYPE_DECIMAL <<
                        CONTENT_COUNTERS_STYLE_SHIFT;
                }

                /* Expect ')' */
                token = parserutils_vector_iterate(vector, ctx);
                if (token == NULL || tokenIsChar(token, ')') == false) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }


                error = css__stylesheet_string_add(c->sheet, lwc_string_ref(name), &name_snumber);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = css__stylesheet_string_add(c->sheet, lwc_string_ref(sep), &sep_snumber);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = CSS_APPEND(opv);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = css__stylesheet_style_append(result, name_snumber);
                if (error != CSS_OK) {
                    *ctx = orig_ctx;
                    return error;
                }

                error = css__stylesheet_style_append(result, sep_snumber);
            }
            else if (first) {
                /* Invalid if this is the first iteration */
                error = CSS_INVALID;
            }
            else {
                /* Give up, ensuring current token is reprocessed */
                *ctx = prev_ctx;
                error = CSS_OK;
                break;
            }

            /* if there was an error bail */
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            first = false;

            consumeWhitespace(vector, ctx);

            prev_ctx = *ctx;
            token = parserutils_vector_iterate(vector, ctx);
        } /* while */

        /* Write list terminator */
        css__stylesheet_style_append(result, CONTENT_NORMAL);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
css_property_parser_gen
*
*********************************************************************************/
/*
 * This file generates parts of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 Vincent Sanders <vince@netsurf-browser.org>
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

 /* Descriptors are space separated key:value pairs brackets () are
  * used to quote in values.
  *
  * Examples:
  * list_style_image:CSS_PROP_LIST_STYLE_IMAGE IDENT:( INHERIT: NONE:0,LIST_STYLE_IMAGE_NONE IDENT:) URI:LIST_STYLE_IMAGE_URI
  *
  * list_style_position:CSS_PROP_LIST_STYLE_POSITION IDENT:( INHERIT: INSIDE:0,LIST_STYLE_POSITION_INSIDE OUTSIDE:0,LIST_STYLE_POSITION_OUTSIDE IDENT:)
 */

struct keyval {
    char* key;
    char* val;
};

struct keyval_list {
    struct keyval* item[100];
    int count;
};

struct keyval* get_keyval(char** pos)
{
    char* endpos;
    struct keyval* nkeyval;
    int kvlen;

    endpos = strchr(*pos, ' '); /* single space separated pairs */
    if (endpos == NULL) {
        /* no space, but might be the end of the input */
        kvlen = strlen(*pos);
        if (kvlen == 0)
            return NULL;
    }
    else {
        kvlen = (endpos - *pos);
    }
    nkeyval = calloc(1, sizeof(struct keyval) + kvlen + 1);

    memcpy(nkeyval + 1, *pos, kvlen);

    nkeyval->key = (char*)nkeyval + sizeof(struct keyval);

    endpos = strchr(nkeyval->key, ':'); /* split key and value on : */
    if (endpos != NULL) {
        endpos[0] = 0; /* change : to null terminator */
        nkeyval->val = endpos + 1; /* skip : */
    }

    *pos += kvlen; /* update position */

    /* skip spaces */
    while ((*pos[0] != 0) &&
        (*pos[0] == ' ')) {
        (*pos)++;
    }

    return nkeyval;
}

void output_header(FILE* outputf, const char* descriptor, struct keyval* parser_id, bool is_generic)
{
    fprintf(outputf,
        "/*\n"
        " * This file was generated by LibCSS gen_parser \n"
        " * \n"
        " * Generated from:\n"
        " *\n"
        " * %s\n"
        " * \n"
        " * Licensed under the MIT License,\n"
        " *		  http://www.opensource.org/licenses/mit-license.php\n"
        " * Copyright 2010 The NetSurf Browser Project.\n"
        " */\n"
        "\n"
        "#include <assert.h>\n"
        "#include <string.h>\n"
        "\n"
        "#include \"bytecode/bytecode.h\"\n"
        "#include \"bytecode/opcodes.h\"\n"
        "#include \"parse/properties/properties.h\"\n"
        "#include \"parse/properties/utils.h\"\n"
        "\n"
        "/**\n"
        " * Parse %s\n"
        " *\n"
        " * \\param c	  Parsing context\n"
        " * \\param vector  Vector of tokens to process\n"
        " * \\param ctx	  Pointer to vector iteration context\n"
        " * \\param result  resulting style\n"
        "%s"
        " * \\return CSS_OK on success,\n"
        " *	   CSS_NOMEM on memory exhaustion,\n"
        " *	   CSS_INVALID if the input is not valid\n"
        " *\n"
        " * Post condition: \\a *ctx is updated with the next token to process\n"
        " *		   If the input is invalid, then \\a *ctx remains unchanged.\n"
        " */\n"
        "css_error css__parse_%s(css_language *c,\n"
        "		const parserutils_vector *vector, int *ctx,\n"
        "		css_style *result%s)\n"
        "{\n",
        descriptor,
        parser_id->key,
        is_generic ? " * \\param op	 Bytecode OpCode for CSS property to encode\n" : "",
        parser_id->key,
        is_generic ? ", enum css_properties_e op" : "");
}


void output_token_type_check(FILE* outputf, bool do_token_check, struct keyval_list* IDENT, struct keyval_list* URI, struct keyval_list* NUMBER)
{
    fprintf(outputf,
        "	int orig_ctx = *ctx;\n"
        "	css_error error;\n"
        "	const css_token *token;\n"
        "	bool match;\n\n"
        "	token = parserutils_vector_iterate(vector, ctx);\n"
        "	if (%stoken == NULL%s",
        do_token_check ? "(" : "",
        do_token_check ? ")" : "");

    if (do_token_check) {
        bool prev = false; /* there was a previous check - add && */
        fprintf(outputf, " || (");

        if (IDENT->count > 0) {
            fprintf(outputf, "(token->type != CSS_TOKEN_IDENT)");
            prev = true;
        }
        if (URI->count > 0) {
            if (prev) fprintf(outputf, " && ");
            fprintf(outputf, "(token->type != CSS_TOKEN_URI)");
            prev = true;
        }
        if (NUMBER->count > 0) {
            if (prev) fprintf(outputf, " && ");
            fprintf(outputf, "(token->type != CSS_TOKEN_NUMBER)");
            prev = true;
        }

        fprintf(outputf, ")");
    }

    fprintf(outputf,
        ") {\n"
        "\t\t*ctx = orig_ctx;\n"
        "\t\treturn CSS_INVALID;\n"
        "\t}\n\n\t");
}

void output_ident(FILE* outputf, bool only_ident, struct keyval* parseid, struct keyval_list* IDENT)
{
    int ident_count;

    for (ident_count = 0; ident_count < IDENT->count; ident_count++) {
        struct keyval* ckv = IDENT->item[ident_count];

        fprintf(outputf,
            "if (");
        if (!only_ident) {
            fprintf(outputf,
                "(token->type == CSS_TOKEN_IDENT) && ");
        }
        fprintf(outputf,
            "(lwc_string_caseless_isequal(token->idata, c->strings[%s], &match) == lwc_error_ok && match)) {\n",
            ckv->key);
        if (strcmp(ckv->key, "INHERIT") == 0) {
            fprintf(outputf,
                "\t\t\terror = css_stylesheet_style_inherit(result, %s);\n",
                parseid->val);
        }
        else {
            fprintf(outputf,
                "\t\t\terror = css__stylesheet_style_appendOPV(result, %s, %s);\n",
                parseid->val,
                ckv->val);
        }
        fprintf(outputf,
            "\t} else ");
    }
}

void output_uri(FILE* outputf, struct keyval* parseid, struct keyval_list* kvlist)
{
    struct keyval* ckv = kvlist->item[0];

    fprintf(outputf,
        "if (token->type == CSS_TOKEN_URI) {\n"
        "		lwc_string *uri = NULL;\n"
        "		uint32_t uri_snumber;\n"
        "\n"
        "		error = c->sheet->resolve(c->sheet->resolve_pw,\n"
        "				c->sheet->url,\n"
        "				token->idata, &uri);\n"
        "		if (error != CSS_OK) {\n"
        "			*ctx = orig_ctx;\n"
        "			return error;\n"
        "		}\n"
        "\n"
        "		error = css__stylesheet_string_add(c->sheet, uri, &uri_snumber);\n"
        "		if (error != CSS_OK) {\n"
        "			*ctx = orig_ctx;\n"
        "			return error;\n"
        "		}\n"
        "\n"
        "		error = css__stylesheet_style_appendOPV(result, %s, 0, %s);\n"
        "		if (error != CSS_OK) {\n"
        "			*ctx = orig_ctx;\n"
        "			return error;\n"
        "		}\n"
        "\n"
        "		error = css__stylesheet_style_append(result, uri_snumber);\n"
        "	} else ",
        parseid->val,
        ckv->val);
}

void output_number(FILE* outputf, struct keyval* parseid, struct keyval_list* kvlist)
{
    struct keyval* ckv = kvlist->item[0];
    int ident_count;

    fprintf(outputf,
        "if (token->type == CSS_TOKEN_NUMBER) {\n"
        "\t\tcss_fixed num = 0;\n"
        "\t\tsize_t consumed = 0;\n\n"
        "\t\tnum = css__number_from_lwc_string(token->idata, %s, &consumed);\n"
        "\t\t/* Invalid if there are trailing characters */\n"
        "\t\tif (consumed != lwc_string_length(token->idata)) {\n"
        "\t\t\t*ctx = orig_ctx;\n"
        "\t\t\treturn CSS_INVALID;\n"
        "\t\t}\n",
        ckv->key);

    for (ident_count = 1; ident_count < kvlist->count; ident_count++) {
        struct keyval* ulkv = kvlist->item[ident_count];

        if (strcmp(ulkv->key, "RANGE") == 0) {
            fprintf(outputf,
                "\t\tif (%s) {\n"
                "\t\t\t*ctx = orig_ctx;\n"
                "\t\t\treturn CSS_INVALID;\n"
                "\t\t}\n\n",
                ulkv->val);
        }

    }

    fprintf(outputf,
        "\t\terror = css__stylesheet_style_appendOPV(result, %s, 0, %s);\n"
        "\t\tif (error != CSS_OK) {\n"
        "\t\t\t*ctx = orig_ctx;\n"
        "\t\t\treturn error;\n"
        "\t\t}\n\n"
        "\t\terror = css__stylesheet_style_append(result, num);\n"
        "\t} else ",
        parseid->val,
        ckv->val);
}

void output_color(FILE* outputf, struct keyval* parseid, struct keyval_list* kvlist)
{
    fprintf(outputf,
        "{\n"
        "\t\tuint16_t value = 0;\n"
        "\t\tuint32_t color = 0;\n"
        "\t\t*ctx = orig_ctx;\n\n"
        "\t\terror = css__parse_colour_specifier(c, vector, ctx, &value, &color);\n"
        "\t\tif (error != CSS_OK) {\n"
        "\t\t\t*ctx = orig_ctx;\n"
        "\t\t\treturn error;\n"
        "\t\t}\n\n"
        "\t\terror = css__stylesheet_style_appendOPV(result, %s, 0, value);\n"
        "\t\tif (error != CSS_OK) {\n"
        "\t\t\t*ctx = orig_ctx;\n"
        "\t\t\treturn error;\n"
        "\t\t}\n"
        "\n"
        "\t\tif (value == COLOR_SET)\n"
        "\t\t\terror = css__stylesheet_style_append(result, color);\n"
        "\t}\n\n",
        parseid->val);
}

void output_length_unit(FILE* outputf, struct keyval* parseid, struct keyval_list* kvlist)
{
    struct keyval* ckv = kvlist->item[0];
    int ident_count;


    fprintf(outputf,
        "{\n"
        "\t\tcss_fixed length = 0;\n"
        "\t\tuint32_t unit = 0;\n"
        "\t\t*ctx = orig_ctx;\n\n"
        "\t\terror = css__parse_unit_specifier(c, vector, ctx, %s, &length, &unit);\n"
        "\t\tif (error != CSS_OK) {\n"
        "\t\t\t*ctx = orig_ctx;\n"
        "\t\t\treturn error;\n"
        "\t\t}\n\n",
        ckv->key);

    for (ident_count = 1; ident_count < kvlist->count; ident_count++) {
        struct keyval* ulkv = kvlist->item[ident_count];

        if (strcmp(ulkv->key, "ALLOW") == 0) {
            fprintf(outputf,
                "\t\tif ((%s) == false) {\n"
                "\t\t\t*ctx = orig_ctx;\n"
                "\t\t\treturn CSS_INVALID;\n"
                "\t\t}\n\n",
                ulkv->val);
        }
        else if (strcmp(ulkv->key, "DISALLOW") == 0) {
            fprintf(outputf,
                "\t\tif (%s) {\n"
                "\t\t\t*ctx = orig_ctx;\n"
                "\t\t\treturn CSS_INVALID;\n"
                "\t\t}\n\n",
                ulkv->val);
        }
        else if (strcmp(ulkv->key, "RANGE") == 0) {
            fprintf(outputf,
                "\t\tif (length %s) {\n"
                "\t\t\t*ctx = orig_ctx;\n"
                "\t\t\treturn CSS_INVALID;\n"
                "\t\t}\n\n",
                ulkv->val);
        }

    }

    fprintf(outputf,
        "\t\terror = css__stylesheet_style_appendOPV(result, %s, 0, %s);\n"
        "\t\tif (error != CSS_OK) {\n"
        "\t\t\t*ctx = orig_ctx;\n"
        "\t\t\treturn error;\n"
        "\t\t}\n"
        "\n"
        "\t\terror = css__stylesheet_style_vappend(result, 2, length, unit);\n"
        "\t}\n\n",
        parseid->val,
        ckv->val);
}

void
output_ident_list(FILE* outputf,
    struct keyval* parseid,
    struct keyval_list* kvlist)
{
    struct keyval* ckv = kvlist->item[0]; /* list type : opv value */
    struct keyval* ikv;

    if (strcmp(ckv->key, "STRING_OPTNUM") != 0) {
        fprintf(stderr, "unknown IDENT list type %s\n", ckv->key);
        exit(4);
    }

    if (kvlist->count < 2) {
        fprintf(stderr, "Not enough parameters to IDENT list type %s\n", ckv->key);
        exit(4);
    }

    /* list of IDENT and optional numbers */
    ikv = kvlist->item[1]; /* numeric default : end condition */

    fprintf(outputf,
        "{\n"
        "\t\terror = css__stylesheet_style_appendOPV(result, %s, 0, %s);\n"
        "\t\tif (error != CSS_OK) {\n"
        "\t\t\t*ctx = orig_ctx;\n"
        "\t\t\treturn error;\n"
        "\t\t}\n\n"
        "\t\twhile ((token != NULL) && (token->type == CSS_TOKEN_IDENT)) {\n"
        "\t\t\tuint32_t snumber;\n"
        "\t\t\tcss_fixed num;\n"
        "\t\t\tint pctx;\n\n"
        "\t\t\terror = css__stylesheet_string_add(c->sheet, lwc_string_ref(token->idata), &snumber);\n"
        "\t\t\tif (error != CSS_OK) {\n"
        "\t\t\t\t*ctx = orig_ctx;\n"
        "\t\t\t\treturn error;\n"
        "\t\t\t}\n\n"
        "\t\t\terror = css__stylesheet_style_append(result, snumber);\n"
        "\t\t\tif (error != CSS_OK) {\n"
        "\t\t\t\t*ctx = orig_ctx;\n"
        "\t\t\t\treturn error;\n"
        "\t\t\t}\n\n"
        "\t\t\tconsumeWhitespace(vector, ctx);\n\n"
        "\t\t\tpctx = *ctx;\n"
        "\t\t\ttoken = parserutils_vector_iterate(vector, ctx);\n"
        "\t\t\tif ((token != NULL) && (token->type == CSS_TOKEN_NUMBER)) {\n"
        "\t\t\t\tsize_t consumed = 0;\n\n"
        "\t\t\t\tnum = css__number_from_lwc_string(token->idata, true, &consumed);\n"
        "\t\t\t\tif (consumed != lwc_string_length(token->idata)) {\n"
        "\t\t\t\t\t*ctx = orig_ctx;\n"
        "\t\t\t\t\treturn CSS_INVALID;\n"
        "\t\t\t\t}\n"
        "\t\t\t\tconsumeWhitespace(vector, ctx);\n\n"
        "\t\t\t\tpctx = *ctx;\n"
        "\t\t\t\ttoken = parserutils_vector_iterate(vector, ctx);\n"
        "\t\t\t} else {\n"
        "\t\t\t\tnum = INTTOFIX(%s);\n"
        "\t\t\t}\n\n"
        "\t\t\terror = css__stylesheet_style_append(result, num);\n"
        "\t\t\tif (error != CSS_OK) {\n"
        "\t\t\t\t*ctx = orig_ctx;\n"
        "\t\t\t\treturn error;\n"
        "\t\t\t}\n\n"
        "\t\t\tif (token == NULL)\n"
        "\t\t\t\tbreak;\n\n"
        "\t\t\tif (token->type == CSS_TOKEN_IDENT) {\n"
        "\t\t\t\terror = css__stylesheet_style_append(result, %s);\n"
        "\t\t\t\tif (error != CSS_OK) {\n"
        "\t\t\t\t\t*ctx = orig_ctx;\n"
        "\t\t\t\t\treturn error;\n"
        "\t\t\t\t}\n"
        "\t\t\t} else {\n"
        "\t\t\t\t*ctx = pctx; /* rewind one token back */\n"
        "\t\t\t}\n"
        "\t\t}\n\n"
        "\t\terror = css__stylesheet_style_append(result, %s);\n"
        "\t}\n\n",
        parseid->val,
        ckv->val,
        ikv->key,
        ckv->val,
        ikv->val);
}

void output_invalidcss(FILE* outputf)
{
    fprintf(outputf, "{\n\t\terror = CSS_INVALID;\n\t}\n\n");
}

void output_footer(FILE* outputf)
{
    fprintf(outputf,
        "	if (error != CSS_OK)\n"
        "		*ctx = orig_ctx;\n"
        "	\n"
        "	return error;\n"
        "}\n\n");
}

void output_wrap(FILE* outputf, struct keyval* parseid, struct keyval_list* WRAP)
{
    struct keyval* ckv = WRAP->item[0];
    fprintf(outputf,
        "	return %s(c, vector, ctx, result, %s);\n}\n",
        ckv->val,
        parseid->val);
}

char str_INHERIT[] = "INHERIT";

struct keyval ident_inherit = {
    .key = str_INHERIT,
};

int css_property_parser_gen(int argc, char** argv)
{
    char* descriptor;
    char* curpos; /* current position in input string */
    struct keyval* parser_id; /* the parser we are creating output for */
    FILE* outputf;
    struct keyval* rkv; /* current read key:val */
    struct keyval_list* curlist;
    bool do_token_check = true; /* if the check for valid tokens is done */
    bool only_ident = true; /* if the only token type is ident */
    bool is_generic = false;

    struct keyval_list base;
    struct keyval_list IDENT;
    struct keyval_list IDENT_LIST;
    struct keyval_list LENGTH_UNIT;
    struct keyval_list URI;
    struct keyval_list WRAP;
    struct keyval_list NUMBER;
    struct keyval_list COLOR;


    if (argc < 2) {
        fprintf(stderr, "Usage: %s [-o <filename>] <descriptor>\n", argv[0]);
        return 1;
    }

    if ((argv[1][0] == '-') && (argv[1][1] == 'o')) {
        if (argc != 4) {
            fprintf(stderr, "Usage: %s [-o <filename>] <descriptor>\n", argv[0]);
            return 1;
        }
        outputf = fopen(argv[2], "w");
        if (outputf == NULL) {
            perror("unable to open file");
            return 2; /* exit on output file output error */
        }
        descriptor = strdup(argv[3]);
    }
    else {
        outputf = stdout;
        descriptor = strdup(argv[1]);
    }
    curpos = descriptor;

    base.count = 0;
    IDENT.count = 0;
    URI.count = 0;
    WRAP.count = 0;
    NUMBER.count = 0;
    COLOR.count = 0;
    LENGTH_UNIT.count = 0;
    IDENT_LIST.count = 0;

    curlist = &base;

    while (*curpos != 0) {
        rkv = get_keyval(&curpos);
        if (rkv == NULL) {
            fprintf(stderr, "Token error at offset %ld\n",
                (long)(curpos - descriptor));
            fclose(outputf);
            return 2;
        }

        if (strcmp(rkv->key, "WRAP") == 0) {
            WRAP.item[WRAP.count++] = rkv;
            only_ident = false;
        }
        else if (strcmp(rkv->key, "NUMBER") == 0) {
            if (rkv->val[0] == '(') {
                curlist = &NUMBER;
            }
            else if (rkv->val[0] == ')') {
                curlist = &base;
            }
            else {
                NUMBER.item[NUMBER.count++] = rkv;
            }
            only_ident = false;
        }
        else if (strcmp(rkv->key, "IDENT") == 0) {
            if (rkv->val[0] == '(') {
                curlist = &IDENT;
            }
            else if (rkv->val[0] == ')') {
                curlist = &base;
            }
            else if (strcmp(rkv->val, str_INHERIT) == 0) {
                IDENT.item[IDENT.count++] = &ident_inherit;
            }
        }
        else if (strcmp(rkv->key, "IDENT_LIST") == 0) {
            if (rkv->val[0] == '(') {
                curlist = &IDENT_LIST;
            }
            else if (rkv->val[0] == ')') {
                curlist = &base;
            }
        }
        else if (strcmp(rkv->key, "LENGTH_UNIT") == 0) {
            if (rkv->val[0] == '(') {
                curlist = &LENGTH_UNIT;
            }
            else if (rkv->val[0] == ')') {
                curlist = &base;
            }
            only_ident = false;
            do_token_check = false;
        }
        else if (strcmp(rkv->key, "COLOR") == 0) {
            COLOR.item[COLOR.count++] = rkv;
            do_token_check = false;
            only_ident = false;
        }
        else if (strcmp(rkv->key, "URI") == 0) {
            URI.item[URI.count++] = rkv;
            only_ident = false;
        }
        else if (strcmp(rkv->key, "GENERIC") == 0) {
            is_generic = true;
        }
        else {
            /* just append to current list */
            curlist->item[curlist->count++] = rkv;
        }
    }

    if (base.count != 1) {
        fprintf(stderr, "Incorrect base element count (got %d expected 1)\n", base.count);
        fclose(outputf);
        return 3;
    }


    /* header */
    output_header(outputf, descriptor, base.item[0], is_generic);

    if (WRAP.count > 0) {
        output_wrap(outputf, base.item[0], &WRAP);
    }
    else {
        /* check token type is correct */
        output_token_type_check(outputf, do_token_check, &IDENT, &URI, &NUMBER);

        if (IDENT.count > 0)
            output_ident(outputf, only_ident, base.item[0], &IDENT);

        if (URI.count > 0)
            output_uri(outputf, base.item[0], &URI);

        if (NUMBER.count > 0)
            output_number(outputf, base.item[0], &NUMBER);

        /* terminal blocks, these end the ladder ie no trailing else */
        if (COLOR.count > 0) {
            output_color(outputf, base.item[0], &COLOR);
        }
        else if (LENGTH_UNIT.count > 0) {
            output_length_unit(outputf, base.item[0], &LENGTH_UNIT);
        }
        else if (IDENT_LIST.count > 0) {
            output_ident_list(outputf, base.item[0], &IDENT_LIST);
        }
        else {
            output_invalidcss(outputf);
        }

        output_footer(outputf);

    }

    fclose(outputf);

    return 0;
}

/*********************************************************************************
cue
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse cue shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_cue(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* first_token;
    const css_token* token;

    /* one or two tokens follow:
     *  if one emit for both BEFORE and AFTER
     *  if two first is before second is after
     *  tokens are either IDENT:none or URI
     */

    first_token = parserutils_vector_peek(vector, *ctx);

    error = css__parse_cue_before(c, vector, ctx, result);
    if (error == CSS_OK) {
        /* first token parsed */

        consumeWhitespace(vector, ctx);

        token = parserutils_vector_peek(vector, *ctx);
        if (token == NULL) {
            /* no second token, re-parse the first */
            *ctx = orig_ctx;
            error = css__parse_cue_after(c, vector, ctx, result);
        }
        else {
            /* second token - might be useful */
            if (is_css_inherit(c, token)) {
                /* another inherit which is bogus */
                error = CSS_INVALID;
            }
            else {
                error = css__parse_cue_after(c, vector, ctx, result);
                if (error == CSS_OK) {
                    /* second token parsed */
                    if (is_css_inherit(c, first_token)) {
                        /* valid second token after inherit */
                        error = CSS_INVALID;
                    }
                }
                else {
                    /* second token appears to be junk re-try with first */
                    *ctx = orig_ctx;
                    error = css__parse_cue_after(c, vector, ctx, result);
                }
            }
        }
    }


    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
cursor
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *                http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse cursor
  *
  * \param c       Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx     Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *         CSS_NOMEM on memory exhaustion,
  *         CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *                 If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_cursor(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error = CSS_OK;
    const css_token* token;
    bool match;

    /* [ (URI ',')* IDENT(auto, crosshair, default, pointer, move, e-resize,
     *              ne-resize, nw-resize, n-resize, se-resize, sw-resize,
     *              s-resize, w-resize, text, wait, help, progress) ]
     * | IDENT(inherit)
     */
    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) ||
        (token->type != CSS_TOKEN_IDENT &&
            token->type != CSS_TOKEN_URI)) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(token->idata,
            c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_CURSOR);
    }
    else {
        bool first = true;

        /* Macro to output the value marker, awkward because we need to check
         * first to determine how the value is constructed.
         */
#define CSS_APPEND(CSSVAL) css__stylesheet_style_append(result, first?buildOPV(CSS_PROP_CURSOR, 0, CSSVAL):CSSVAL)


         /* URI* */
        while (token != NULL && token->type == CSS_TOKEN_URI) {
            lwc_string* uri;
            uint32_t uri_snumber;

            error = c->sheet->resolve(c->sheet->resolve_pw,
                c->sheet->url,
                token->idata, &uri);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            error = css__stylesheet_string_add(c->sheet,
                uri,
                &uri_snumber);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            error = CSS_APPEND(CURSOR_URI);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            error = css__stylesheet_style_append(result, uri_snumber);
            if (error != CSS_OK) {
                *ctx = orig_ctx;
                return error;
            }

            consumeWhitespace(vector, ctx);

            /* Expect ',' */
            token = parserutils_vector_iterate(vector, ctx);
            if (token == NULL || tokenIsChar(token, ',') == false) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            consumeWhitespace(vector, ctx);

            /* Expect either URI or IDENT */
            token = parserutils_vector_iterate(vector, ctx);
            if (token == NULL || (token->type != CSS_TOKEN_IDENT &&
                token->type != CSS_TOKEN_URI)) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            first = false;
        }

        /* IDENT */
        if (token != NULL && token->type == CSS_TOKEN_IDENT) {
            if ((lwc_string_caseless_isequal(
                token->idata, c->strings[AUTO],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_AUTO);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[CROSSHAIR],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_CROSSHAIR);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[DEFAULT],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_DEFAULT);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[POINTER],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_POINTER);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[MOVE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_MOVE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[E_RESIZE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_E_RESIZE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[NE_RESIZE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_NE_RESIZE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[NW_RESIZE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_NW_RESIZE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[N_RESIZE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_N_RESIZE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[SE_RESIZE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_SE_RESIZE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[SW_RESIZE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_SW_RESIZE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[S_RESIZE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_S_RESIZE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[W_RESIZE],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_W_RESIZE);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[LIBCSS_TEXT],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_TEXT);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[WAIT],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_WAIT);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[HELP],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_HELP);
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[PROGRESS],
                &match) == lwc_error_ok && match)) {
                error = CSS_APPEND(CURSOR_PROGRESS);
            }
            else {
                error = CSS_INVALID;
            }
        }

    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
elevation
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse elevation
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_elevation(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    uint8_t flags = 0;
    uint16_t value = 0;
    css_fixed length = 0;
    uint32_t unit = 0;
    bool match;

    /* angle | IDENT(below, level, above, higher, lower, inherit) */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        flags = FLAG_INHERIT;
    }
    else if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[BELOW],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        value = ELEVATION_BELOW;
    }
    else if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[LEVEL],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        value = ELEVATION_LEVEL;
    }
    else if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[ABOVE],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        value = ELEVATION_ABOVE;
    }
    else if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[HIGHER],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        value = ELEVATION_HIGHER;
    }
    else if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[LOWER],
            &match) == lwc_error_ok && match)) {
        parserutils_vector_iterate(vector, ctx);
        value = ELEVATION_LOWER;
    }
    else {
        error = css__parse_unit_specifier(c, vector, ctx, UNIT_DEG,
            &length, &unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        if ((unit & UNIT_ANGLE) == false) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        /* Valid angles lie between -90 and 90 degrees */
        if (unit == UNIT_DEG) {
            if (length < -F_90 || length > F_90) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        else if (unit == UNIT_GRAD) {
            if (length < -F_100 || length > F_100) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        else if (unit == UNIT_RAD) {
            if (length < -F_PI_2 || length > F_PI_2) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }

        value = ELEVATION_ANGLE;
    }

    error = css__stylesheet_style_appendOPV(result, CSS_PROP_ELEVATION, flags, value);
    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    if (((flags & FLAG_INHERIT) == false) && (value == ELEVATION_ANGLE)) {
        error = css__stylesheet_style_vappend(result, 2, length, unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }
    }

    return CSS_OK;
}

/*********************************************************************************
flex
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2017 Lucas Neves <lcneves@gmail.com>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse list-style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */

css_error css__parse_flex(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_error error;
    bool grow = true;
    bool shrink = true;
    bool basis = true;
    css_style* grow_style;
    css_style* shrink_style;
    css_style* basis_style;
    bool short_auto = false;
    bool short_none = false;
    bool match;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result,
            CSS_PROP_FLEX_GROW);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result,
            CSS_PROP_FLEX_SHRINK);

        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result,
            CSS_PROP_FLEX_BASIS);

        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* allocate styles */
    error = css__stylesheet_style_create(c->sheet, &grow_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &shrink_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(grow_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &basis_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(grow_style);
        css__stylesheet_style_destroy(shrink_style);
        return error;
    }

    /* Handle shorthand none, equivalent of flex: 0 0 auto; */
    if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[NONE],
            &match) == lwc_error_ok && match)) {
        short_none = true;
        parserutils_vector_iterate(vector, ctx);

    }
    else if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[AUTO],
            &match) == lwc_error_ok && match)) {
        /* Handle shorthand auto, equivalent of flex: 1 1 auto; */
        short_auto = true;
        parserutils_vector_iterate(vector, ctx);

    }
    else do {
        /* Attempt to parse the various longhand properties */
        prev_ctx = *ctx;
        error = CSS_OK;

        /* Ensure that we're not about to parse another inherit */
        token = parserutils_vector_peek(vector, *ctx);
        if (token != NULL && is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_flex_cleanup;
        }

        if ((grow) &&
            (error = css__parse_flex_grow(c, vector,
                ctx, grow_style)) == CSS_OK) {
            grow = false;
        }
        else if ((basis) &&
            (error = css__parse_flex_basis(c, vector,
                ctx, basis_style)) == CSS_OK) {
            basis = false;
        }
        else if ((shrink) &&
            (error = css__parse_flex_shrink(c, vector,
                ctx, shrink_style)) == CSS_OK) {
            shrink = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);
            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while (*ctx != prev_ctx && token != NULL);

    /* defaults */
    if (grow) {
        error = css__stylesheet_style_appendOPV(grow_style,
            CSS_PROP_FLEX_GROW, 0, FLEX_GROW_SET);
        if (error != CSS_OK)
            goto css__parse_flex_cleanup;

        css_fixed grow_num = short_auto ? INTTOFIX(1) : 0;
        error = css__stylesheet_style_append(grow_style, grow_num);
        if (error != CSS_OK)
            goto css__parse_flex_cleanup;
    }

    if (shrink) {
        error = css__stylesheet_style_appendOPV(shrink_style,
            CSS_PROP_FLEX_SHRINK, 0, FLEX_SHRINK_SET);
        if (error != CSS_OK)
            goto css__parse_flex_cleanup;

        css_fixed shrink_num = short_none ? 0 : INTTOFIX(1);
        error = css__stylesheet_style_append(shrink_style, shrink_num);
        if (error != CSS_OK)
            goto css__parse_flex_cleanup;
    }

    if (basis) {
        /* Default is auto, but zero if grow or shrink are set */
        if (!grow || !shrink) {
            error = css__stylesheet_style_appendOPV(basis_style,
                CSS_PROP_FLEX_BASIS, 0,
                FLEX_BASIS_SET);
            if (error != CSS_OK)
                goto css__parse_flex_cleanup;

            error = css__stylesheet_style_vappend(
                basis_style, 2, 0, UNIT_PX);
            if (error != CSS_OK)
                goto css__parse_flex_cleanup;

        }
        else {
            error = css__stylesheet_style_appendOPV(basis_style,
                CSS_PROP_FLEX_BASIS, 0,
                FLEX_BASIS_AUTO);
            if (error != CSS_OK)
                goto css__parse_flex_cleanup;
        }
    }

    error = css__stylesheet_merge_style(result, grow_style);
    if (error != CSS_OK)
        goto css__parse_flex_cleanup;

    error = css__stylesheet_merge_style(result, shrink_style);
    if (error != CSS_OK)
        goto css__parse_flex_cleanup;

    error = css__stylesheet_merge_style(result, basis_style);

css__parse_flex_cleanup:

    css__stylesheet_style_destroy(basis_style);
    css__stylesheet_style_destroy(shrink_style);
    css__stylesheet_style_destroy(grow_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
flex_flow
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2017 Lucas Neves <lcneves@gmail.com>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse flex-flow
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */

css_error css__parse_flex_flow(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_error error;
    bool direction = true;
    bool wrap = true;
    css_style* direction_style;
    css_style* wrap_style;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result,
            CSS_PROP_FLEX_DIRECTION);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result,
            CSS_PROP_FLEX_WRAP);

        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* allocate styles */
    error = css__stylesheet_style_create(c->sheet, &direction_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &wrap_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(direction_style);
        return error;
    }

    /* Attempt to parse the various longhand properties */
    do {
        prev_ctx = *ctx;
        error = CSS_OK;

        /* Ensure that we're not about to parse another inherit */
        token = parserutils_vector_peek(vector, *ctx);
        if (token != NULL && is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_flex_flow_cleanup;
        }

        if ((wrap) &&
            (error = css__parse_flex_wrap(c, vector,
                ctx, wrap_style)) == CSS_OK) {
            wrap = false;
        }
        else if ((direction) &&
            (error = css__parse_flex_direction(c, vector,
                ctx, direction_style)) == CSS_OK) {
            direction = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while (*ctx != prev_ctx && token != NULL);


    /* defaults */
    if (direction) {
        error = css__stylesheet_style_appendOPV(direction_style,
            CSS_PROP_FLEX_DIRECTION,
            0, FLEX_DIRECTION_ROW);
    }

    if (wrap) {
        error = css__stylesheet_style_appendOPV(wrap_style,
            CSS_PROP_FLEX_WRAP,
            0, FLEX_WRAP_NOWRAP);
    }

    error = css__stylesheet_merge_style(result, direction_style);
    if (error != CSS_OK)
        goto css__parse_flex_flow_cleanup;

    error = css__stylesheet_merge_style(result, wrap_style);

css__parse_flex_flow_cleanup:

    css__stylesheet_style_destroy(wrap_style);
    css__stylesheet_style_destroy(direction_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
font
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"



static css_error parse_system_font(css_language* c,
    css_style* result, css_system_font* system_font)
{
    css_error error;
    bool match;

    /* style */
    switch (system_font->style) {
    case CSS_FONT_STYLE_NORMAL:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0, FONT_STYLE_NORMAL);
        break;

    case CSS_FONT_STYLE_ITALIC:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0, FONT_STYLE_ITALIC);
        break;

    case CSS_FONT_STYLE_OBLIQUE:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0, FONT_STYLE_OBLIQUE);
        break;

    default:
        error = CSS_BADPARM;
        break;
    }
    if (error != CSS_OK)
        return error;

    /* variant */
    switch (system_font->variant) {
    case CSS_FONT_VARIANT_NORMAL:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_VARIANT, 0, FONT_VARIANT_NORMAL);
        break;

    case CSS_FONT_VARIANT_SMALL_CAPS:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_VARIANT, 0, FONT_VARIANT_SMALL_CAPS);
        break;

    default:
        error = CSS_BADPARM;
        break;
    }
    if (error != CSS_OK)
        return error;

    /* weight */
    switch (system_font->weight) {
    case CSS_FONT_WEIGHT_NORMAL:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_NORMAL);
        break;

    case CSS_FONT_WEIGHT_BOLD:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_BOLD);
        break;

    case CSS_FONT_WEIGHT_BOLDER:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_BOLDER);
        break;

    case CSS_FONT_WEIGHT_LIGHTER:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_LIGHTER);
        break;

    case CSS_FONT_WEIGHT_100:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_100);
        break;

    case CSS_FONT_WEIGHT_200:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_200);
        break;

    case CSS_FONT_WEIGHT_300:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_300);
        break;

    case CSS_FONT_WEIGHT_400:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_400);
        break;

    case CSS_FONT_WEIGHT_500:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_500);
        break;

    case CSS_FONT_WEIGHT_600:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_600);
        break;

    case CSS_FONT_WEIGHT_700:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_700);
        break;

    case CSS_FONT_WEIGHT_800:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_800);
        break;

    case CSS_FONT_WEIGHT_900:
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_WEIGHT, 0, FONT_WEIGHT_900);
        break;

    default:
        error = CSS_BADPARM;
        break;
    }
    if (error != CSS_OK)
        return error;

    /* size */
    error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_DIMENSION);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_vappend(result, 2, system_font->size.size, system_font->size.unit);
    if (error != CSS_OK)
        return error;

    /* line height */
    error = css__stylesheet_style_appendOPV(result, CSS_PROP_LINE_HEIGHT, 0, LINE_HEIGHT_DIMENSION);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_vappend(result, 2, system_font->line_height.size, system_font->line_height.unit);
    if (error != CSS_OK)
        return error;

    /* font family */
    if ((lwc_string_caseless_isequal(system_font->family, c->strings[SERIF], &match) == lwc_error_ok && match))
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_FAMILY, 0, FONT_FAMILY_SERIF);
    else if ((lwc_string_caseless_isequal(system_font->family, c->strings[SANS_SERIF], &match) == lwc_error_ok && match))
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_FAMILY, 0, FONT_FAMILY_SANS_SERIF);
    else if ((lwc_string_caseless_isequal(system_font->family, c->strings[CURSIVE], &match) == lwc_error_ok && match))
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_FAMILY, 0, FONT_FAMILY_CURSIVE);
    else if ((lwc_string_caseless_isequal(system_font->family, c->strings[FANTASY], &match) == lwc_error_ok && match))
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_FAMILY, 0, FONT_FAMILY_FANTASY);
    else if ((lwc_string_caseless_isequal(system_font->family, c->strings[MONOSPACE], &match) == lwc_error_ok && match))
        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_FAMILY, 0, FONT_FAMILY_MONOSPACE);
    else {
        uint32_t snumber;

        error = css__stylesheet_string_add(c->sheet, lwc_string_ref(system_font->family), &snumber);
        if (error != CSS_OK)
            return error;

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_FAMILY, 0, FONT_FAMILY_STRING);
        if (error != CSS_OK)
            return error;

        error = css__stylesheet_style_append(result, snumber);
    }
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_append(result, FONT_FAMILY_END);

    return error;
}

/**
 * Parse font
 *
 * \param c	  Parsing context
 * \param vector  Vector of tokens to process
 * \param ctx	  Pointer to vector iteration context
 * \param result  Pointer to location to receive resulting style
 * \return CSS_OK on success,
 *	   CSS_NOMEM on memory exhaustion,
 *	   CSS_INVALID if the input is not valid
 *
 * Post condition: \a *ctx is updated with the next token to process
 *		   If the input is invalid, then \a *ctx remains unchanged.
 */
css_error css__parse_font(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    const css_token* token;
    css_error error;
    int orig_ctx = *ctx;
    int prev_ctx;
    css_system_font system_font;

    bool style = true;
    bool variant = true;
    bool weight = true;
    bool line_height = true;
    css_style* style_style;
    css_style* variant_style;
    css_style* weight_style;
    css_style* size_style;
    css_style* line_height_style;
    css_style* family_style;
    int svw;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_STYLE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_VARIANT);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_WEIGHT);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_SIZE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_LINE_HEIGHT);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_FAMILY);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Perhaps an unknown font name; ask the client */
    if ((token->type == CSS_TOKEN_IDENT) &&
        (c->sheet->font != NULL) &&
        (c->sheet->font(c->sheet->font_pw,
            token->idata,
            &system_font) == CSS_OK)) {

        error = parse_system_font(c, result, &system_font);

        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }


    /* allocate styles */
    error = css__stylesheet_style_create(c->sheet, &style_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &variant_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(style_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &weight_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(style_style);
        css__stylesheet_style_destroy(variant_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &size_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(style_style);
        css__stylesheet_style_destroy(variant_style);
        css__stylesheet_style_destroy(weight_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &line_height_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(style_style);
        css__stylesheet_style_destroy(variant_style);
        css__stylesheet_style_destroy(weight_style);
        css__stylesheet_style_destroy(size_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &family_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(style_style);
        css__stylesheet_style_destroy(variant_style);
        css__stylesheet_style_destroy(weight_style);
        css__stylesheet_style_destroy(size_style);
        css__stylesheet_style_destroy(line_height_style);
        return error;
    }


    /* Attempt to parse the optional style, variant, and weight */
    for (svw = 0; svw < 3; svw++) {
        prev_ctx = *ctx;
        error = CSS_OK;

        /* Ensure that we're not about to parse another inherit */
        token = parserutils_vector_peek(vector, *ctx);
        if ((token != NULL) && is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_font_cleanup;
        }

        if ((style) &&
            (error = css__parse_font_style(c, vector,
                ctx, style_style)) == CSS_OK) {
            style = false;
        }
        else if ((variant) &&
            (error = css__parse_font_variant(c, vector, ctx,
                variant_style)) == CSS_OK) {
            variant = false;
        }
        else if ((weight) &&
            (error = css__parse_font_weight(c, vector, ctx,
                weight_style)) == CSS_OK) {
            weight = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);
        }
        else {
            break;
        }

        if (*ctx == prev_ctx)
            break;
    }

    consumeWhitespace(vector, ctx);

    /* Ensure that we're not about to parse another inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if ((token != NULL) && is_css_inherit(c, token)) {
        error = CSS_INVALID;
        goto css__parse_font_cleanup;
    }

    /* Now expect a font-size */
    error = css__parse_font_size(c, vector, ctx, size_style);
    if (error != CSS_OK)
        goto css__parse_font_cleanup;

    consumeWhitespace(vector, ctx);

    /* Potential line-height */
    token = parserutils_vector_peek(vector, *ctx);
    if ((token != NULL) && tokenIsChar(token, '/')) {
        parserutils_vector_iterate(vector, ctx);

        consumeWhitespace(vector, ctx);

        /* Ensure that we're not about to parse another inherit */
        token = parserutils_vector_peek(vector, *ctx);
        if ((token != NULL) && is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_font_cleanup;
        }

        error = css__parse_line_height(c, vector, ctx, line_height_style);
        if (error != CSS_OK)
            goto css__parse_font_cleanup;

        line_height = false;
    }

    consumeWhitespace(vector, ctx);

    /* Ensure that we're not about to parse another inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if ((token != NULL) && is_css_inherit(c, token)) {
        error = CSS_INVALID;
        goto css__parse_font_cleanup;
    }

    /* Now expect a font-family */
    error = css__parse_font_family(c, vector, ctx, family_style);
    if (error != CSS_OK)
        goto css__parse_font_cleanup;

    /* defaults */
    if (style) {
        error = css__stylesheet_style_appendOPV(style_style,
            CSS_PROP_FONT_STYLE, 0,
            FONT_STYLE_NORMAL);
        if (error != CSS_OK)
            goto css__parse_font_cleanup;
    }

    if (variant) {
        error = css__stylesheet_style_appendOPV(variant_style,
            CSS_PROP_FONT_VARIANT, 0,
            FONT_VARIANT_NORMAL);
        if (error != CSS_OK)
            goto css__parse_font_cleanup;
    }

    if (weight) {
        error = css__stylesheet_style_appendOPV(weight_style,
            CSS_PROP_FONT_WEIGHT,
            0, FONT_WEIGHT_NORMAL);
        if (error != CSS_OK)
            goto css__parse_font_cleanup;
    }

    if (line_height) {
        error = css__stylesheet_style_appendOPV(line_height_style,
            CSS_PROP_LINE_HEIGHT,
            0, LINE_HEIGHT_NORMAL);
        if (error != CSS_OK)
            goto css__parse_font_cleanup;
    }

    /* merge final output */
    error = css__stylesheet_merge_style(result, style_style);
    if (error != CSS_OK)
        goto css__parse_font_cleanup;

    error = css__stylesheet_merge_style(result, variant_style);
    if (error != CSS_OK)
        goto css__parse_font_cleanup;

    error = css__stylesheet_merge_style(result, weight_style);
    if (error != CSS_OK)
        goto css__parse_font_cleanup;

    error = css__stylesheet_merge_style(result, size_style);
    if (error != CSS_OK)
        goto css__parse_font_cleanup;

    error = css__stylesheet_merge_style(result, line_height_style);
    if (error != CSS_OK)
        goto css__parse_font_cleanup;

    error = css__stylesheet_merge_style(result, family_style);



css__parse_font_cleanup:
    css__stylesheet_style_destroy(style_style);
    css__stylesheet_style_destroy(variant_style);
    css__stylesheet_style_destroy(weight_style);
    css__stylesheet_style_destroy(size_style);
    css__stylesheet_style_destroy(line_height_style);
    css__stylesheet_style_destroy(family_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}







/*********************************************************************************
font_family
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Determine if a given font-family ident is reserved
  *
  * \param c	 Parsing context
  * \param ident	 IDENT to consider
  * \return True if IDENT is reserved, false otherwise
  */
static bool font_family_reserved(css_language* c, const css_token* ident)
{
    bool match;

    return (lwc_string_caseless_isequal(
        ident->idata, c->strings[SERIF],
        &match) == lwc_error_ok && match) ||
        (lwc_string_caseless_isequal(
            ident->idata, c->strings[SANS_SERIF],
            &match) == lwc_error_ok && match) ||
        (lwc_string_caseless_isequal(
            ident->idata, c->strings[CURSIVE],
            &match) == lwc_error_ok && match) ||
        (lwc_string_caseless_isequal(
            ident->idata, c->strings[FANTASY],
            &match) == lwc_error_ok && match) ||
        (lwc_string_caseless_isequal(
            ident->idata, c->strings[MONOSPACE],
            &match) == lwc_error_ok && match);
}

/**
 * Convert a font-family token into a bytecode value
 *
 * \param c	 Parsing context
 * \param token	 Token to consider
 * \param first  Whether the token is the first
 * \return Bytecode value
 */
static css_code_t font_family_value(css_language* c, const css_token* token, bool first)
{
    uint16_t value;
    bool match;

    if (token->type == CSS_TOKEN_IDENT) {
        if ((lwc_string_caseless_isequal(
            token->idata, c->strings[SERIF],
            &match) == lwc_error_ok && match))
            value = FONT_FAMILY_SERIF;
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[SANS_SERIF],
            &match) == lwc_error_ok && match))
            value = FONT_FAMILY_SANS_SERIF;
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[CURSIVE],
            &match) == lwc_error_ok && match))
            value = FONT_FAMILY_CURSIVE;
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[FANTASY],
            &match) == lwc_error_ok && match))
            value = FONT_FAMILY_FANTASY;
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[MONOSPACE],
            &match) == lwc_error_ok && match))
            value = FONT_FAMILY_MONOSPACE;
        else
            value = FONT_FAMILY_IDENT_LIST;
    }
    else {
        value = FONT_FAMILY_STRING;
    }

    return first ? buildOPV(CSS_PROP_FONT_FAMILY, 0, value) : value;
}

/**
 * Parse font-family
 *
 * \param c	  Parsing context
 * \param vector  Vector of tokens to process
 * \param ctx	  Pointer to vector iteration context
 * \param result  Pointer to location to receive resulting style
 * \return CSS_OK on success,
 *	   CSS_NOMEM on memory exhaustion,
 *	   CSS_INVALID if the input is not valid
 *
 * Post condition: \a *ctx is updated with the next token to process
 *		   If the input is invalid, then \a *ctx remains unchanged.
 */
css_error css__parse_font_family(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    /* [ IDENT+ | STRING ] [ ',' [ IDENT+ | STRING ] ]* | IDENT(inherit)
     *
     * In the case of IDENT+, any whitespace between tokens is collapsed to
     * a single space
     *
     * \todo Mozilla makes the comma optional.
     * Perhaps this is a quirk we should inherit?
     */

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL || (token->type != CSS_TOKEN_IDENT &&
        token->type != CSS_TOKEN_STRING)) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_FONT_FAMILY);
    }
    else {
        *ctx = orig_ctx;

        error = css__comma_list_to_style(c, vector, ctx,
            font_family_reserved, font_family_value,
            result);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, FONT_FAMILY_END);
    }

    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    return CSS_OK;
}

/*********************************************************************************
font_weight
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse font-weight
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_font_weight(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    uint8_t flags = 0;
    uint16_t value = 0;
    bool match;

    /* NUMBER (100, 200, 300, 400, 500, 600, 700, 800, 900) |
     * IDENT (normal, bold, bolder, lighter, inherit) */
    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL || (token->type != CSS_TOKEN_IDENT &&
        token->type != CSS_TOKEN_NUMBER)) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(
        token->idata, c->strings[INHERIT],
        &match) == lwc_error_ok && match)) {
        flags |= FLAG_INHERIT;
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        size_t consumed = 0;
        css_fixed num = css__number_from_lwc_string(token->idata,
            true, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        switch (FIXTOINT(num)) {
        case 100: value = FONT_WEIGHT_100; break;
        case 200: value = FONT_WEIGHT_200; break;
        case 300: value = FONT_WEIGHT_300; break;
        case 400: value = FONT_WEIGHT_400; break;
        case 500: value = FONT_WEIGHT_500; break;
        case 600: value = FONT_WEIGHT_600; break;
        case 700: value = FONT_WEIGHT_700; break;
        case 800: value = FONT_WEIGHT_800; break;
        case 900: value = FONT_WEIGHT_900; break;
        default: *ctx = orig_ctx; return CSS_INVALID;
        }
    }
    else if ((lwc_string_caseless_isequal(
        token->idata, c->strings[NORMAL],
        &match) == lwc_error_ok && match)) {
        value = FONT_WEIGHT_NORMAL;
    }
    else if ((lwc_string_caseless_isequal(
        token->idata, c->strings[BOLD],
        &match) == lwc_error_ok && match)) {
        value = FONT_WEIGHT_BOLD;
    }
    else if ((lwc_string_caseless_isequal(
        token->idata, c->strings[BOLDER],
        &match) == lwc_error_ok && match)) {
        value = FONT_WEIGHT_BOLDER;
    }
    else if ((lwc_string_caseless_isequal(
        token->idata, c->strings[LIGHTER],
        &match) == lwc_error_ok && match)) {
        value = FONT_WEIGHT_LIGHTER;
    }
    else {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    error = css__stylesheet_style_appendOPV(result,
        CSS_PROP_FONT_WEIGHT,
        flags,
        value);
    if (error != CSS_OK)
        *ctx = orig_ctx;


    return error;
}

/*********************************************************************************
list_style
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse list-style
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_list_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_error error;
    bool image = true;
    bool position = true;
    bool type = true;
    css_style* image_style;
    css_style* position_style;
    css_style* type_style;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_LIST_STYLE_IMAGE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_LIST_STYLE_POSITION);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_LIST_STYLE_TYPE);

        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* allocate styles */
    error = css__stylesheet_style_create(c->sheet, &image_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &position_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(image_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &type_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(image_style);
        css__stylesheet_style_destroy(position_style);
        return error;
    }

    /* Attempt to parse the various longhand properties */
    do {
        prev_ctx = *ctx;
        error = CSS_OK;

        /* Ensure that we're not about to parse another inherit */
        token = parserutils_vector_peek(vector, *ctx);
        if (token != NULL && is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_list_style_cleanup;
        }

        if ((type) &&
            (error = css__parse_list_style_type(c, vector,
                ctx, type_style)) == CSS_OK) {
            type = false;
        }
        else if ((position) &&
            (error = css__parse_list_style_position(c, vector,
                ctx, position_style)) == CSS_OK) {
            position = false;
        }
        else if ((image) &&
            (error = css__parse_list_style_image(c, vector, ctx,
                image_style)) == CSS_OK) {
            image = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while (*ctx != prev_ctx && token != NULL);


    /* defaults */
    if (image) {
        error = css__stylesheet_style_appendOPV(image_style,
            CSS_PROP_LIST_STYLE_IMAGE,
            0, LIST_STYLE_IMAGE_NONE);
    }

    if (position) {
        error = css__stylesheet_style_appendOPV(position_style,
            CSS_PROP_LIST_STYLE_POSITION,
            0, LIST_STYLE_POSITION_OUTSIDE);
    }

    if (type) {
        error = css__stylesheet_style_appendOPV(type_style,
            CSS_PROP_LIST_STYLE_TYPE,
            0, LIST_STYLE_TYPE_DISC);
    }


    error = css__stylesheet_merge_style(result, image_style);
    if (error != CSS_OK)
        goto css__parse_list_style_cleanup;

    error = css__stylesheet_merge_style(result, position_style);
    if (error != CSS_OK)
        goto css__parse_list_style_cleanup;

    error = css__stylesheet_merge_style(result, type_style);


css__parse_list_style_cleanup:

    css__stylesheet_style_destroy(type_style);
    css__stylesheet_style_destroy(position_style);
    css__stylesheet_style_destroy(image_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;

}

/*********************************************************************************
list_style_type
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse list-style-type
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_list_style_type(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* ident;
    uint8_t flags = 0;
    uint16_t value = 0;
    bool match;

    /* IDENT (disc, circle, square, decimal, decimal-leading-zero,
     *	  lower-roman, upper-roman, lower-greek, lower-latin,
     *	  upper-latin, armenian, georgian, lower-alpha, upper-alpha,
     *	  none, inherit)
     */
    ident = parserutils_vector_iterate(vector, ctx);
    if (ident == NULL || ident->type != CSS_TOKEN_IDENT) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[INHERIT],
        &match) == lwc_error_ok && match)) {
        flags |= FLAG_INHERIT;
    }
    else {
        error = css__parse_list_style_type_value(c, ident, &value);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }
    }

    error = css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_TYPE, flags, value);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
margin
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse margin shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_margin(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    uint16_t side_val[4];
    css_fixed side_length[4];
    uint32_t side_unit[4];
    uint32_t side_count = 0;
    bool match;
    css_error error;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_MARGIN_TOP);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_MARGIN_RIGHT);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_MARGIN_BOTTOM);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_MARGIN_LEFT);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Attempt to parse up to 4 widths */
    do {
        prev_ctx = *ctx;

        if ((token != NULL) && is_css_inherit(c, token)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[AUTO], &match) == lwc_error_ok && match)) {
            side_val[side_count] = MARGIN_AUTO;
            parserutils_vector_iterate(vector, ctx);
            error = CSS_OK;
        }
        else {
            side_val[side_count] = MARGIN_SET;

            error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &side_length[side_count], &side_unit[side_count]);
            if (error == CSS_OK) {
                if (side_unit[side_count] & UNIT_ANGLE ||
                    side_unit[side_count] & UNIT_TIME ||
                    side_unit[side_count] & UNIT_FREQ) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
        }

        if (error == CSS_OK) {
            side_count++;

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while ((*ctx != prev_ctx) && (token != NULL) && (side_count < 4));


#define SIDE_APPEND(OP,NUM)								\
	error = css__stylesheet_style_appendOPV(result, (OP), 0, side_val[(NUM)]);	\
	if (error != CSS_OK)								\
		break;									\
	if (side_val[(NUM)] == MARGIN_SET) {						\
		error = css__stylesheet_style_append(result, side_length[(NUM)]);	\
		if (error != CSS_OK)							\
			break;								\
		error = css__stylesheet_style_append(result, side_unit[(NUM)]);		\
		if (error != CSS_OK)							\
			break;								\
	}

    switch (side_count) {
    case 1:
        SIDE_APPEND(CSS_PROP_MARGIN_TOP, 0);
        SIDE_APPEND(CSS_PROP_MARGIN_RIGHT, 0);
        SIDE_APPEND(CSS_PROP_MARGIN_BOTTOM, 0);
        SIDE_APPEND(CSS_PROP_MARGIN_LEFT, 0);
        break;
    case 2:
        SIDE_APPEND(CSS_PROP_MARGIN_TOP, 0);
        SIDE_APPEND(CSS_PROP_MARGIN_RIGHT, 1);
        SIDE_APPEND(CSS_PROP_MARGIN_BOTTOM, 0);
        SIDE_APPEND(CSS_PROP_MARGIN_LEFT, 1);
        break;
    case 3:
        SIDE_APPEND(CSS_PROP_MARGIN_TOP, 0);
        SIDE_APPEND(CSS_PROP_MARGIN_RIGHT, 1);
        SIDE_APPEND(CSS_PROP_MARGIN_BOTTOM, 2);
        SIDE_APPEND(CSS_PROP_MARGIN_LEFT, 1);
        break;
    case 4:
        SIDE_APPEND(CSS_PROP_MARGIN_TOP, 0);
        SIDE_APPEND(CSS_PROP_MARGIN_RIGHT, 1);
        SIDE_APPEND(CSS_PROP_MARGIN_BOTTOM, 2);
        SIDE_APPEND(CSS_PROP_MARGIN_LEFT, 3);
        break;
    default:
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
opacity
*
*********************************************************************************/
/*
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2010 The NetSurf Browser Project.
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse opacity
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_opacity(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT) && (token->type != CSS_TOKEN_NUMBER))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) && (lwc_string_caseless_isequal(token->idata, c->strings[INHERIT], &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_OPACITY);
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        css_fixed num = 0;
        size_t consumed = 0;

        num = css__number_from_lwc_string(token->idata, false, &consumed);
        /* Invalid if there are trailing characters */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        /* Clamp to range [0,1] */
        if (num < 0)
            num = 0;
        if (num > INTTOFIX(1))
            num = INTTOFIX(1);

        error = css__stylesheet_style_appendOPV(result, CSS_PROP_OPACITY, 0, OPACITY_SET);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, num);
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
outline
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse outline shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_outline(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_error error;
    bool color = true;
    bool style = true;
    bool width = true;
    css_style* color_style;
    css_style* style_style;
    css_style* width_style;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_OUTLINE_COLOR);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_OUTLINE_STYLE);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_OUTLINE_WIDTH);

        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* allocate styles */
    error = css__stylesheet_style_create(c->sheet, &color_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &style_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(color_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &width_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(color_style);
        css__stylesheet_style_destroy(style_style);
        return error;
    }

    /* Attempt to parse the various longhand properties */
    do {
        prev_ctx = *ctx;
        error = CSS_OK;

        /* Ensure that we're not about to parse another inherit */
        token = parserutils_vector_peek(vector, *ctx);
        if (token != NULL && is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_outline_cleanup;
        }

        if ((color) &&
            (error = css__parse_outline_color(c, vector, ctx,
                color_style)) == CSS_OK) {
            color = false;
        }
        else if ((style) &&
            (error = css__parse_outline_style(c, vector,
                ctx, style_style)) == CSS_OK) {
            style = false;
        }
        else if ((width) &&
            (error = css__parse_outline_width(c, vector,
                ctx, width_style)) == CSS_OK) {
            width = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while (*ctx != prev_ctx && token != NULL);


    /* defaults */
    if (color) {
        error = css__stylesheet_style_appendOPV(color_style,
            CSS_PROP_OUTLINE_COLOR,
            0, OUTLINE_COLOR_INVERT);
    }

    if (style) {
        error = css__stylesheet_style_appendOPV(style_style,
            CSS_PROP_OUTLINE_STYLE,
            0, OUTLINE_STYLE_NONE);
    }

    if (width) {
        error = css__stylesheet_style_appendOPV(width_style,
            CSS_PROP_OUTLINE_WIDTH,
            0, OUTLINE_WIDTH_MEDIUM);
    }


    error = css__stylesheet_merge_style(result, color_style);
    if (error != CSS_OK)
        goto css__parse_outline_cleanup;

    error = css__stylesheet_merge_style(result, style_style);
    if (error != CSS_OK)
        goto css__parse_outline_cleanup;

    error = css__stylesheet_merge_style(result, width_style);


css__parse_outline_cleanup:

    css__stylesheet_style_destroy(width_style);
    css__stylesheet_style_destroy(style_style);
    css__stylesheet_style_destroy(color_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
overflow
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2012 Michael Drake <tlsa@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse overflow shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_overflow(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error1, error2 = CSS_OK;
    const css_token* token;
    bool match;

    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || ((token->type != CSS_TOKEN_IDENT))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((lwc_string_caseless_isequal(token->idata,
        c->strings[INHERIT], &match) == lwc_error_ok &&
        match)) {
        error1 = css_stylesheet_style_inherit(result,
            CSS_PROP_OVERFLOW_X);
        error2 = css_stylesheet_style_inherit(result,
            CSS_PROP_OVERFLOW_Y);

    }
    else if ((lwc_string_caseless_isequal(token->idata,
        c->strings[VISIBLE], &match) == lwc_error_ok &&
        match)) {
        error1 = css__stylesheet_style_appendOPV(result,
            CSS_PROP_OVERFLOW_X, 0, OVERFLOW_VISIBLE);
        error2 = css__stylesheet_style_appendOPV(result,
            CSS_PROP_OVERFLOW_Y, 0, OVERFLOW_VISIBLE);

    }
    else if ((lwc_string_caseless_isequal(token->idata,
        c->strings[HIDDEN], &match) == lwc_error_ok &&
        match)) {
        error1 = css__stylesheet_style_appendOPV(result,
            CSS_PROP_OVERFLOW_X, 0, OVERFLOW_HIDDEN);
        error2 = css__stylesheet_style_appendOPV(result,
            CSS_PROP_OVERFLOW_Y, 0, OVERFLOW_HIDDEN);

    }
    else if ((lwc_string_caseless_isequal(token->idata,
        c->strings[SCROLL], &match) == lwc_error_ok &&
        match)) {
        error1 = css__stylesheet_style_appendOPV(result,
            CSS_PROP_OVERFLOW_X, 0, OVERFLOW_SCROLL);
        error2 = css__stylesheet_style_appendOPV(result,
            CSS_PROP_OVERFLOW_Y, 0, OVERFLOW_SCROLL);

    }
    else if ((lwc_string_caseless_isequal(token->idata,
        c->strings[AUTO], &match) == lwc_error_ok &&
        match)) {
        error1 = css__stylesheet_style_appendOPV(result,
            CSS_PROP_OVERFLOW_X, 0, OVERFLOW_AUTO);
        error2 = css__stylesheet_style_appendOPV(result,
            CSS_PROP_OVERFLOW_Y, 0, OVERFLOW_AUTO);

    }
    else {
        error1 = CSS_INVALID;
    }

    if (error2 != CSS_OK)
        error1 = error2;

    if (error1 != CSS_OK)
        *ctx = orig_ctx;

    return error1;
}


/*********************************************************************************
padding
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse padding shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_padding(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_fixed side_length[4];
    uint32_t side_unit[4];
    uint32_t side_count = 0;
    css_error error;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_PADDING_TOP);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_PADDING_RIGHT);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_PADDING_BOTTOM);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_PADDING_LEFT);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* Attempt to parse up to 4 widths */
    do {
        prev_ctx = *ctx;

        if ((token != NULL) && is_css_inherit(c, token)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        error = css__parse_unit_specifier(c, vector, ctx, UNIT_PX, &side_length[side_count], &side_unit[side_count]);
        if (error == CSS_OK) {
            if (side_unit[side_count] & UNIT_ANGLE ||
                side_unit[side_count] & UNIT_TIME ||
                side_unit[side_count] & UNIT_FREQ) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            if (side_length[side_count] < 0) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            side_count++;

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while ((*ctx != prev_ctx) && (token != NULL) && (side_count < 4));

#define SIDE_APPEND(OP,NUM)							\
	error = css__stylesheet_style_appendOPV(result, (OP), 0, PADDING_SET);	\
	if (error != CSS_OK)							\
		break;								\
	error = css__stylesheet_style_append(result, side_length[(NUM)]);	\
	if (error != CSS_OK)							\
		break;								\
	error = css__stylesheet_style_append(result, side_unit[(NUM)]);		\
	if (error != CSS_OK)							\
		break;

    switch (side_count) {
    case 1:
        SIDE_APPEND(CSS_PROP_PADDING_TOP, 0);
        SIDE_APPEND(CSS_PROP_PADDING_RIGHT, 0);
        SIDE_APPEND(CSS_PROP_PADDING_BOTTOM, 0);
        SIDE_APPEND(CSS_PROP_PADDING_LEFT, 0);
        break;
    case 2:
        SIDE_APPEND(CSS_PROP_PADDING_TOP, 0);
        SIDE_APPEND(CSS_PROP_PADDING_RIGHT, 1);
        SIDE_APPEND(CSS_PROP_PADDING_BOTTOM, 0);
        SIDE_APPEND(CSS_PROP_PADDING_LEFT, 1);
        break;
    case 3:
        SIDE_APPEND(CSS_PROP_PADDING_TOP, 0);
        SIDE_APPEND(CSS_PROP_PADDING_RIGHT, 1);
        SIDE_APPEND(CSS_PROP_PADDING_BOTTOM, 2);
        SIDE_APPEND(CSS_PROP_PADDING_LEFT, 1);
        break;
    case 4:
        SIDE_APPEND(CSS_PROP_PADDING_TOP, 0);
        SIDE_APPEND(CSS_PROP_PADDING_RIGHT, 1);
        SIDE_APPEND(CSS_PROP_PADDING_BOTTOM, 2);
        SIDE_APPEND(CSS_PROP_PADDING_LEFT, 3);
        break;
    default:
        error = CSS_INVALID;
        break;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
pause
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse pause shorthand
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_pause(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* first_token;
    const css_token* token;

    /* one or two tokens follow:
     *  if one emit for both BEFORE and AFTER
     *  if two first is before second is after
     *  tokens are either IDENT:none or URI
     */

    first_token = parserutils_vector_peek(vector, *ctx);

    error = css__parse_pause_before(c, vector, ctx, result);
    if (error == CSS_OK) {
        /* first token parsed */

        consumeWhitespace(vector, ctx);

        token = parserutils_vector_peek(vector, *ctx);
        if (token == NULL) {
            /* no second token, re-parse the first */
            *ctx = orig_ctx;
            error = css__parse_pause_after(c, vector, ctx, result);
        }
        else {
            /* second token - might be useful */
            if (is_css_inherit(c, token)) {
                /* another bogus inherit */
                error = CSS_INVALID;
            }
            else {
                error = css__parse_pause_after(c, vector, ctx, result);
                if (error == CSS_OK) {
                    /* second token parsed */
                    if (is_css_inherit(c, first_token)) {
                        /* valid second token after inherit */
                        error = CSS_INVALID;
                    }
                }
                else {
                    /* second token appears to be junk re-try with first */
                    *ctx = orig_ctx;
                    error = css__parse_pause_after(c, vector, ctx, result);
                }
            }
        }
    }


    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
play_during
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse play-during
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_play_during(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    uint8_t flags = 0;
    uint16_t value = 0;
    lwc_string* uri;
    bool match;
    uint32_t uri_snumber;

    /* URI [ IDENT(mix) || IDENT(repeat) ]? | IDENT(auto,none,inherit) */
    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) ||
        ((token->type != CSS_TOKEN_IDENT) &&
            (token->type != CSS_TOKEN_URI))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if (token->type == CSS_TOKEN_IDENT) {
        if ((lwc_string_caseless_isequal(
            token->idata, c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
            flags |= FLAG_INHERIT;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[NONE],
            &match) == lwc_error_ok && match)) {
            value = PLAY_DURING_NONE;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[AUTO],
            &match) == lwc_error_ok && match)) {
            value = PLAY_DURING_AUTO;
        }
        else {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
    }
    else {
        int modifiers;

        value = PLAY_DURING_URI;

        error = c->sheet->resolve(c->sheet->resolve_pw,
            c->sheet->url,
            token->idata, &uri);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_string_add(c->sheet,
            uri,
            &uri_snumber);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }


        for (modifiers = 0; modifiers < 2; modifiers++) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
            if (token != NULL && token->type == CSS_TOKEN_IDENT) {
                if ((lwc_string_caseless_isequal(
                    token->idata, c->strings[MIX],
                    &match) == lwc_error_ok &&
                    match)) {
                    if ((value & PLAY_DURING_MIX) == 0)
                        value |= PLAY_DURING_MIX;
                    else {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                }
                else if (lwc_string_caseless_isequal(
                    token->idata,
                    c->strings[REPEAT],
                    &match) == lwc_error_ok &&
                    match) {
                    if ((value & PLAY_DURING_REPEAT) == 0)
                        value |= PLAY_DURING_REPEAT;
                    else {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                }
                else {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                parserutils_vector_iterate(vector, ctx);
            }
        }
    }

    error = css__stylesheet_style_appendOPV(result, CSS_PROP_PLAY_DURING, flags, value);
    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    if ((flags & FLAG_INHERIT) == false &&
        (value & PLAY_DURING_TYPE_MASK) == PLAY_DURING_URI) {
        error = css__stylesheet_style_append(result, uri_snumber);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
properties
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *                http://www.opensource.org/licenses/mit-license.php
 * Copyright 2008 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include "thirdparty/libcss/libcss/parse/properties/properties.h"

 /**
  * Dispatch table of property handlers, indexed by property enum
  */
const css_prop_handler property_handlers[LAST_PROP + 1 - FIRST_PROP] =
{
    css__parse_align_content,
    css__parse_align_items,
    css__parse_align_self,
    css__parse_azimuth,
    css__parse_background,
    css__parse_background_attachment,
    css__parse_background_color,
    css__parse_background_image,
    css__parse_background_position,
    css__parse_background_repeat,
    css__parse_border,
    css__parse_border_bottom,
    css__parse_border_bottom_color,
    css__parse_border_bottom_style,
    css__parse_border_bottom_width,
    css__parse_border_collapse,
    css__parse_border_color,
    css__parse_border_left,
    css__parse_border_left_color,
    css__parse_border_left_style,
    css__parse_border_left_width,
    css__parse_border_right,
    css__parse_border_right_color,
    css__parse_border_right_style,
    css__parse_border_right_width,
    css__parse_border_spacing,
    css__parse_border_style,
    css__parse_border_top,
    css__parse_border_top_color,
    css__parse_border_top_style,
    css__parse_border_top_width,
    css__parse_border_width,
    css__parse_border_radius,
    css__parse_border_radius_top_left,
    css__parse_border_radius_top_right,
    css__parse_border_radius_bottom_right,
    css__parse_border_radius_bottom_left,
    css__parse_bottom,
    css__parse_box_sizing,
    css__parse_break_after,
    css__parse_break_before,
    css__parse_break_inside,
    css__parse_caption_side,
    css__parse_clear,
    css__parse_clip,
    css__parse_color,
    css__parse_columns,
    css__parse_column_count,
    css__parse_column_fill,
    css__parse_column_gap,
    css__parse_column_rule,
    css__parse_column_rule_color,
    css__parse_column_rule_style,
    css__parse_column_rule_width,
    css__parse_column_span,
    css__parse_column_width,
    css__parse_content,
    css__parse_counter_increment,
    css__parse_counter_reset,
    css__parse_cue,
    css__parse_cue_after,
    css__parse_cue_before,
    css__parse_cursor,
    css__parse_direction,
    css__parse_display,
    css__parse_elevation,
    css__parse_empty_cells,
    css__parse_flex,
    css__parse_flex_basis,
    css__parse_flex_direction,
    css__parse_flex_flow,
    css__parse_flex_grow,
    css__parse_flex_shrink,
    css__parse_flex_wrap,
    css__parse_float,
    css__parse_font,
    css__parse_font_family,
    css__parse_font_size,
    css__parse_font_style,
    css__parse_font_variant,
    css__parse_font_weight,
    css__parse_height,
    css__parse_justify_content,
    css__parse_left,
    css__parse_letter_spacing,
    css__parse_line_height,
    css__parse_list_style,
    css__parse_list_style_image,
    css__parse_list_style_position,
    css__parse_list_style_type,
    css__parse_margin,
    css__parse_margin_bottom,
    css__parse_margin_left,
    css__parse_margin_right,
    css__parse_margin_top,
    css__parse_max_height,
    css__parse_max_width,
    css__parse_min_height,
    css__parse_min_width,
    css__parse_opacity,
    css__parse_order,
    css__parse_orphans,
    css__parse_outline,
    css__parse_outline_color,
    css__parse_outline_style,
    css__parse_outline_width,
    css__parse_overflow,
    css__parse_overflow_x,
    css__parse_overflow_y,
    css__parse_padding,
    css__parse_padding_bottom,
    css__parse_padding_left,
    css__parse_padding_right,
    css__parse_padding_top,
    css__parse_page_break_after,
    css__parse_page_break_before,
    css__parse_page_break_inside,
    css__parse_pause,
    css__parse_pause_after,
    css__parse_pause_before,
    css__parse_pitch_range,
    css__parse_pitch,
    css__parse_play_during,
    css__parse_position,
    css__parse_quotes,
    css__parse_richness,
    css__parse_right,
    css__parse_speak_header,
    css__parse_speak_numeral,
    css__parse_speak_punctuation,
    css__parse_speak,
    css__parse_speech_rate,
    css__parse_stress,
    css__parse_table_layout,
    css__parse_text_align,
    css__parse_text_decoration,
    css__parse_text_indent,
    css__parse_text_transform,
    css__parse_top,
    css__parse_unicode_bidi,
    css__parse_vertical_align,
    css__parse_visibility,
    css__parse_voice_family,
    css__parse_volume,
    css__parse_white_space,
    css__parse_widows,
    css__parse_width,
    css__parse_word_spacing,
    css__parse_writing_mode,
    css__parse_z_index
};

/*********************************************************************************
quotes
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse quotes
  *
  * \param c	  Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx	  Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *	   CSS_NOMEM on memory exhaustion,
  *	   CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *		   If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_quotes(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error = CSS_INVALID;
    const css_token* token;
    bool match;

    /* [ STRING STRING ]+ | IDENT(none,inherit) */
    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) ||
        ((token->type != CSS_TOKEN_IDENT) &&
            (token->type != CSS_TOKEN_STRING))) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(token->idata,
            c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_QUOTES);
    }
    else if ((token->type == CSS_TOKEN_IDENT) &&
        (lwc_string_caseless_isequal(token->idata,
            c->strings[NONE],
            &match) == lwc_error_ok && match)) {
        error = css__stylesheet_style_appendOPV(result,
            CSS_PROP_QUOTES, 0, QUOTES_NONE);
    }
    else if (token->type == CSS_TOKEN_STRING) {
        bool first = true;

        /* Macro to output the value marker, awkward because we need to check
         * first to determine how the value is constructed.
         */
#define CSS_FIRST_APPEND(CSSVAL) css__stylesheet_style_append(result, first?buildOPV(CSS_PROP_QUOTES, 0, CSSVAL):CSSVAL)

         /* [ STRING STRING ]+ */
        while ((token != NULL) && (token->type == CSS_TOKEN_STRING)) {
            uint32_t open_snumber;
            uint32_t close_snumber;

            error = css__stylesheet_string_add(c->sheet,
                lwc_string_ref(token->idata),
                &open_snumber);
            if (error != CSS_OK)
                break;

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_iterate(vector, ctx);
            if ((token == NULL) ||
                (token->type != CSS_TOKEN_STRING)) {
                error = CSS_INVALID;
                break;
            }

            error = css__stylesheet_string_add(c->sheet,
                lwc_string_ref(token->idata),
                &close_snumber);
            if (error != CSS_OK)
                break;

            consumeWhitespace(vector, ctx);

            error = CSS_FIRST_APPEND(QUOTES_STRING);
            if (error != CSS_OK)
                break;

            error = css__stylesheet_style_append(result, open_snumber);
            if (error != CSS_OK)
                break;

            error = css__stylesheet_style_append(result, close_snumber);
            if (error != CSS_OK)
                break;

            first = false;

            token = parserutils_vector_peek(vector, *ctx);
            if (token == NULL || token->type != CSS_TOKEN_STRING)
                break;
            token = parserutils_vector_iterate(vector, ctx);
        }

        if (error == CSS_OK) {
            /* AddTerminator */
            error = css__stylesheet_style_append(result, QUOTES_NONE);
        }
    }
    else {
        error = CSS_INVALID;
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
text_decoration
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Parse text-decoration
  *
  * \param c       Parsing context
  * \param vector  Vector of tokens to process
  * \param ctx     Pointer to vector iteration context
  * \param result  Pointer to location to receive resulting style
  * \return CSS_OK on success,
  *         CSS_NOMEM on memory exhaustion,
  *         CSS_INVALID if the input is not valid
  *
  * Post condition: \a *ctx is updated with the next token to process
  *                 If the input is invalid, then \a *ctx remains unchanged.
  */
css_error css__parse_text_decoration(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error = CSS_INVALID;
    const css_token* token;
    bool match;

    /* IDENT([ underline || overline || line-through || blink ])
     * | IDENT (none, inherit) */
    token = parserutils_vector_iterate(vector, ctx);
    if ((token == NULL) || (token->type != CSS_TOKEN_IDENT)) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if (lwc_string_caseless_isequal(token->idata,
        c->strings[INHERIT],
        &match) == lwc_error_ok && match) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_TEXT_DECORATION);
    }
    else if (lwc_string_caseless_isequal(token->idata,
        c->strings[NONE],
        &match) == lwc_error_ok && match) {
        error = css__stylesheet_style_appendOPV(result,
            CSS_PROP_TEXT_DECORATION, 0, TEXT_DECORATION_NONE);
    }
    else {
        uint16_t value = 0;
        while (token != NULL) {
            if ((lwc_string_caseless_isequal(
                token->idata, c->strings[UNDERLINE],
                &match) == lwc_error_ok && match)) {
                if ((value & TEXT_DECORATION_UNDERLINE) == 0)
                    value |= TEXT_DECORATION_UNDERLINE;
                else {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[OVERLINE],
                &match) == lwc_error_ok && match)) {
                if ((value & TEXT_DECORATION_OVERLINE) == 0)
                    value |= TEXT_DECORATION_OVERLINE;
                else {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[LINE_THROUGH],
                &match) == lwc_error_ok && match)) {
                if ((value & TEXT_DECORATION_LINE_THROUGH) == 0)
                    value |= TEXT_DECORATION_LINE_THROUGH;
                else {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
            else if ((lwc_string_caseless_isequal(
                token->idata, c->strings[BLINK],
                &match) == lwc_error_ok && match)) {
                if ((value & TEXT_DECORATION_BLINK) == 0)
                    value |= TEXT_DECORATION_BLINK;
                else {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
            else {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
            if (token != NULL && token->type != CSS_TOKEN_IDENT)
                break;
            token = parserutils_vector_iterate(vector, ctx);
        }
        error = css__stylesheet_style_appendOPV(result,
            CSS_PROP_TEXT_DECORATION, 0, value);
    }

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/*********************************************************************************
utils
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>


#include "thirdparty/libcss/libcss/stylesheetImpl.h"
#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"

#include "thirdparty/libcss/libcss/utils/parserutilserror.h"

#define strncasecmp(a,b,c)  _strnicmp(a,b,c)

 /**
  * Parse list-style-type value
  *
  * \param c	 Parsing context
  * \param ident	 Identifier to consider
  * \param value	 Pointer to location to receive value
  * \return CSS_OK on success,
  *	   CSS_INVALID if the input is not valid
  */
css_error css__parse_list_style_type_value(css_language* c, const css_token* ident,
    uint16_t* value)
{
    bool match;

    /* IDENT (disc, circle, square, decimal, decimal-leading-zero,
     *	  lower-roman, upper-roman, lower-greek, lower-latin,
     *	  upper-latin, armenian, georgian, lower-alpha, upper-alpha,
     *	  none)
     */
    if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[DISC],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_DISC;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[CIRCLE],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_CIRCLE;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[SQUARE],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_SQUARE;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[DECIMAL],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_DECIMAL;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[DECIMAL_LEADING_ZERO],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_DECIMAL_LEADING_ZERO;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[LOWER_ROMAN],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_LOWER_ROMAN;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[UPPER_ROMAN],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_UPPER_ROMAN;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[LOWER_GREEK],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_LOWER_GREEK;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[LOWER_LATIN],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_LOWER_LATIN;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[UPPER_LATIN],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_UPPER_LATIN;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[ARMENIAN],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_ARMENIAN;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[GEORGIAN],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_GEORGIAN;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[LOWER_ALPHA],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_LOWER_ALPHA;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[UPPER_ALPHA],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_UPPER_ALPHA;
    }
    else if ((lwc_string_caseless_isequal(
        ident->idata, c->strings[NONE],
        &match) == lwc_error_ok && match)) {
        *value = LIST_STYLE_TYPE_NONE;
    }
    else
        return CSS_INVALID;

    return CSS_OK;
}



/**
 * Parse border-{top,right,bottom,left} shorthand
 *
 * \param c	  Parsing context
 * \param vector  Vector of tokens to process
 * \param ctx	  Pointer to vector iteration context
 * \param side	  The side we're parsing for
 * \param result  Pointer to location to receive resulting style
 * \return CSS_OK on success,
 *	   CSS_NOMEM on memory exhaustion,
 *	   CSS_INVALID if the input is not valid
 *
 * Post condition: \a *ctx is updated with the next token to process
 *		   If the input is invalid, then \a *ctx remains unchanged.
 */
css_error css__parse_border_side(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result, enum border_side_e side)
{
    int orig_ctx = *ctx;
    int prev_ctx;
    const css_token* token;
    css_error error = CSS_OK;
    bool color = true;
    bool style = true;
    bool width = true;
    css_style* color_style;
    css_style* style_style;
    css_style* width_style;

    /* Firstly, handle inherit */
    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (is_css_inherit(c, token)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_TOP_COLOR + side);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_TOP_STYLE + side);
        if (error != CSS_OK)
            return error;

        error = css_stylesheet_style_inherit(result, CSS_PROP_BORDER_TOP_WIDTH + side);
        if (error == CSS_OK)
            parserutils_vector_iterate(vector, ctx);

        return error;
    }

    /* allocate styles */
    error = css__stylesheet_style_create(c->sheet, &color_style);
    if (error != CSS_OK)
        return error;

    error = css__stylesheet_style_create(c->sheet, &style_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(color_style);
        return error;
    }

    error = css__stylesheet_style_create(c->sheet, &width_style);
    if (error != CSS_OK) {
        css__stylesheet_style_destroy(color_style);
        css__stylesheet_style_destroy(style_style);
        return error;
    }

    /* Attempt to parse the various longhand properties */
    do {
        prev_ctx = *ctx;
        error = CSS_OK;

        /* Ensure that we're not about to parse another inherit */
        token = parserutils_vector_peek(vector, *ctx);
        if (token != NULL && is_css_inherit(c, token)) {
            error = CSS_INVALID;
            goto css__parse_border_side_cleanup;
        }

        /* Try each property parser in turn, but only if we
         * haven't already got a value for this property.
         */
        if ((color) &&
            (error = css__parse_border_side_color(c, vector, ctx,
                color_style, CSS_PROP_BORDER_TOP_COLOR + side)) == CSS_OK) {
            color = false;
        }
        else if ((style) &&
            (error = css__parse_border_side_style(c, vector, ctx,
                style_style, CSS_PROP_BORDER_TOP_STYLE + side)) == CSS_OK) {
            style = false;
        }
        else if ((width) &&
            (error = css__parse_border_side_width(c, vector, ctx,
                width_style, CSS_PROP_BORDER_TOP_WIDTH + side)) == CSS_OK) {
            width = false;
        }

        if (error == CSS_OK) {
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
        }
        else {
            /* Forcibly cause loop to exit */
            token = NULL;
        }
    } while (*ctx != prev_ctx && token != NULL);

    if (style) {
        error = css__stylesheet_style_appendOPV(style_style,
            CSS_PROP_BORDER_TOP_STYLE + side, 0,
            BORDER_STYLE_NONE);
        if (error != CSS_OK)
            goto css__parse_border_side_cleanup;
    }

    if (width) {
        error = css__stylesheet_style_appendOPV(width_style,
            CSS_PROP_BORDER_TOP_WIDTH + side, 0,
            BORDER_WIDTH_MEDIUM);
        if (error != CSS_OK)
            goto css__parse_border_side_cleanup;
    }

    if (color) {
        error = css__stylesheet_style_appendOPV(color_style,
            CSS_PROP_BORDER_TOP_COLOR + side, 0,
            BORDER_COLOR_CURRENT_COLOR);
        if (error != CSS_OK)
            goto css__parse_border_side_cleanup;
    }

    error = css__stylesheet_merge_style(result, color_style);
    if (error != CSS_OK)
        goto css__parse_border_side_cleanup;

    error = css__stylesheet_merge_style(result, style_style);
    if (error != CSS_OK)
        goto css__parse_border_side_cleanup;

    error = css__stylesheet_merge_style(result, width_style);

css__parse_border_side_cleanup:
    css__stylesheet_style_destroy(color_style);
    css__stylesheet_style_destroy(style_style);
    css__stylesheet_style_destroy(width_style);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/**
 * Convert Hue Saturation Lightness value to RGB.
 *
 * \param hue Hue in degrees 0..360
 * \param sat Saturation value in percent 0..100
 * \param lit Lightness value in percent 0..100
 * \param r red component
 * \param g green component
 * \param b blue component
 */
static void HSL_to_RGB(css_fixed hue, css_fixed sat, css_fixed lit, uint8_t* r, uint8_t* g, uint8_t* b)
{
    css_fixed min_rgb, max_rgb, chroma;
    css_fixed relative_hue, scaled_hue, mid1, mid2;
    int sextant;

#define ORGB(R, G, B) \
	*r = FIXTOINT(FDIV(FMUL((R), F_255), F_100)); \
	*g = FIXTOINT(FDIV(FMUL((G), F_255), F_100)); \
	*b = FIXTOINT(FDIV(FMUL((B), F_255), F_100))

    /* If saturation is zero there is no hue and r = g = b = lit */
    if (sat == INTTOFIX(0)) {
        ORGB(lit, lit, lit);
        return;
    }

    /* Compute max(r,g,b) */
    if (lit <= INTTOFIX(50)) {
        max_rgb = FDIV(FMUL(lit, FADD(sat, F_100)), F_100);
    }
    else {
        max_rgb = FDIV(FSUB(FMUL(FADD(lit, sat), F_100), FMUL(lit, sat)), F_100);
    }

    /* Compute min(r,g,b) */
    min_rgb = FSUB(FMUL(lit, INTTOFIX(2)), max_rgb);

    /* We know that the value of at least one of the components is
     * max(r,g,b) and that the value of at least one of the other
     * components is min(r,g,b).
     *
     * We can determine which components have these values by
     * considering which the sextant of the hexcone the hue lies
     * in:
     *
     * Sextant:	max(r,g,b):	min(r,g,b):
     *
     * 0		r		b
     * 1		g		b
     * 2		g		r
     * 3		b		r
     * 4		b		g
     * 5		r		g
     *
     * Thus, we need only compute the value of the third component
     */

     /* Chroma is the difference between min and max */
    chroma = FSUB(max_rgb, min_rgb);

    /* Compute which sextant the hue lies in (truncates result) */
    hue = FDIV(FMUL(hue, INTTOFIX(6)), F_360);
    sextant = FIXTOINT(hue);

    /* Compute offset of hue from start of sextant */
    relative_hue = FSUB(hue, INTTOFIX(sextant));

    /* Scale offset by chroma */
    scaled_hue = FMUL(relative_hue, chroma);

    /* Compute potential values of the third colour component */
    mid1 = FADD(min_rgb, scaled_hue);
    mid2 = FSUB(max_rgb, scaled_hue);

    /* Populate result */
    switch (sextant) {
    case 0: ORGB(max_rgb, mid1, min_rgb); break;
    case 1: ORGB(mid2, max_rgb, min_rgb); break;
    case 2: ORGB(min_rgb, max_rgb, mid1); break;
    case 3: ORGB(min_rgb, mid2, max_rgb); break;
    case 4: ORGB(mid1, min_rgb, max_rgb); break;
    case 5: ORGB(max_rgb, min_rgb, mid2); break;
    }

#undef ORGB
}

/**
 * Parse a colour specifier
 *
 * \param c       Parsing context
 * \param vector  Vector of tokens to process
 * \param ctx     Pointer to vector iteration context
 * \param value   Pointer to location to receive value
 * \param result  Pointer to location to receive result (AARRGGBB)
 * \return CSS_OK      on success,
 *         CSS_INVALID if the input is invalid
 *
 * Post condition: \a *ctx is updated with the next token to process
 *                 If the input is invalid, then \a *ctx remains unchanged.
 */
css_error css__parse_colour_specifier(css_language* c,
    const parserutils_vector* vector, int* ctx,
    uint16_t* value, uint32_t* result)
{
    int orig_ctx = *ctx;
    const css_token* token;
    bool match;
    css_error error;

    consumeWhitespace(vector, ctx);

    /* IDENT(<colour name>) |
     * HASH(rgb | rrggbb) |
     * FUNCTION(rgb) [ [ NUMBER | PERCENTAGE ] ',' ] {3} ')'
     * FUNCTION(rgba) [ [ NUMBER | PERCENTAGE ] ',' ] {4} ')'
     * FUNCTION(hsl) ANGLE ',' PERCENTAGE ',' PERCENTAGE  ')'
     * FUNCTION(hsla) ANGLE ',' PERCENTAGE ',' PERCENTAGE ',' NUMBER ')'
     *
     * For quirks, NUMBER | DIMENSION | IDENT, too
     * I.E. "123456" -> NUMBER, "1234f0" -> DIMENSION, "f00000" -> IDENT
     */
    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL || (token->type != CSS_TOKEN_IDENT &&
        token->type != CSS_TOKEN_HASH &&
        token->type != CSS_TOKEN_FUNCTION)) {
        if (c->sheet->quirks_allowed == false ||
            token == NULL ||
            (token->type != CSS_TOKEN_NUMBER &&
                token->type != CSS_TOKEN_DIMENSION))
            goto invalid;
    }

    if (token->type == CSS_TOKEN_IDENT) {
        if ((lwc_string_caseless_isequal(
            token->idata, c->strings[TRANSPARENT],
            &match) == lwc_error_ok && match)) {
            *value = COLOR_TRANSPARENT;
            *result = 0; /* black transparent */
            return CSS_OK;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[CURRENTCOLOR],
            &match) == lwc_error_ok && match)) {
            *value = COLOR_CURRENT_COLOR;
            *result = 0;
            return CSS_OK;
        }

        error = css__parse_named_colour(c, token->idata, result);
        if (error != CSS_OK && c->sheet->quirks_allowed) {
            error = css__parse_hash_colour(token->idata, result);
            if (error == CSS_OK)
                c->sheet->quirks_used = true;
        }

        if (error != CSS_OK)
            goto invalid;
    }
    else if (token->type == CSS_TOKEN_HASH) {
        error = css__parse_hash_colour(token->idata, result);
        if (error != CSS_OK)
            goto invalid;
    }
    else if (c->sheet->quirks_allowed &&
        token->type == CSS_TOKEN_NUMBER) {
        error = css__parse_hash_colour(token->idata, result);
        if (error == CSS_OK)
            c->sheet->quirks_used = true;
        else
            goto invalid;
    }
    else if (c->sheet->quirks_allowed &&
        token->type == CSS_TOKEN_DIMENSION) {
        error = css__parse_hash_colour(token->idata, result);
        if (error == CSS_OK)
            c->sheet->quirks_used = true;
        else
            goto invalid;
    }
    else if (token->type == CSS_TOKEN_FUNCTION) {
        uint8_t r = 0, g = 0, b = 0, a = 0xff;
        int colour_channels = 0;

        if ((lwc_string_caseless_isequal(
            token->idata, c->strings[RGB],
            &match) == lwc_error_ok && match)) {
            colour_channels = 3;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[RGBA],
            &match) == lwc_error_ok && match)) {
            colour_channels = 4;
        } if ((lwc_string_caseless_isequal(
            token->idata, c->strings[HSL],
            &match) == lwc_error_ok && match)) {
            colour_channels = 5;
        }
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[HSLA],
            &match) == lwc_error_ok && match)) {
            colour_channels = 6;
        }

        if (colour_channels == 3 || colour_channels == 4) {
            int i;
            css_token_type valid = CSS_TOKEN_NUMBER;
            uint8_t* components[4] = { &r, &g, &b, &a };

            for (i = 0; i < colour_channels; i++) {
                uint8_t* component;
                css_fixed num;
                size_t consumed = 0;
                int32_t intval;
                bool int_only;

                component = components[i];

                consumeWhitespace(vector, ctx);

                token = parserutils_vector_peek(vector, *ctx);
                if (token == NULL || (token->type !=
                    CSS_TOKEN_NUMBER &&
                    token->type !=
                    CSS_TOKEN_PERCENTAGE))
                    goto invalid;

                if (i == 0)
                    valid = token->type;
                else if (i < 3 && token->type != valid)
                    goto invalid;

                /* The alpha channel may be a float */
                if (i < 3)
                    int_only = (valid == CSS_TOKEN_NUMBER);
                else
                    int_only = false;

                num = css__number_from_lwc_string(token->idata,
                    int_only, &consumed);
                if (consumed != lwc_string_length(token->idata))
                    goto invalid;

                if (valid == CSS_TOKEN_NUMBER) {
                    if (i == 3) {
                        /* alpha channel */
                        intval = FIXTOINT(
                            FMUL(num, F_255));
                    }
                    else {
                        /* colour channels */
                        intval = FIXTOINT(num);
                    }
                }
                else {
                    intval = FIXTOINT(
                        FDIV(FMUL(num, F_255), F_100));
                }

                if (intval > 255)
                    *component = 255;
                else if (intval < 0)
                    *component = 0;
                else
                    *component = intval;

                parserutils_vector_iterate(vector, ctx);

                consumeWhitespace(vector, ctx);

                token = parserutils_vector_peek(vector, *ctx);
                if (token == NULL)
                    goto invalid;

                if (i != (colour_channels - 1) &&
                    tokenIsChar(token, ',')) {
                    parserutils_vector_iterate(vector, ctx);
                }
                else if (i == (colour_channels - 1) &&
                    tokenIsChar(token, ')')) {
                    parserutils_vector_iterate(vector, ctx);
                }
                else {
                    goto invalid;
                }
            }
        }
        else if (colour_channels == 5 || colour_channels == 6) {
            /* hue - saturation - lightness */
            size_t consumed = 0;
            css_fixed hue, sat, lit;
            int32_t alpha = 255;

            /* hue is a number without a unit representing an
             * angle (0-360) degrees
             */
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_iterate(vector, ctx);
            if ((token == NULL) || (token->type != CSS_TOKEN_NUMBER))
                goto invalid;

            hue = css__number_from_lwc_string(token->idata, false, &consumed);
            if (consumed != lwc_string_length(token->idata))
                goto invalid; /* failed to consume the whole string as a number */

            /* Normalise hue to the range [0, 360) */
            while (hue < 0)
                hue += F_360;
            while (hue >= F_360)
                hue -= F_360;

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_iterate(vector, ctx);
            if (!tokenIsChar(token, ','))
                goto invalid;


            /* saturation */
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_iterate(vector, ctx);
            if ((token == NULL) || (token->type != CSS_TOKEN_PERCENTAGE))
                goto invalid;

            sat = css__number_from_lwc_string(token->idata, false, &consumed);
            if (consumed != lwc_string_length(token->idata))
                goto invalid; /* failed to consume the whole string as a number */

            /* Normalise saturation to the range [0, 100] */
            if (sat < INTTOFIX(0))
                sat = INTTOFIX(0);
            else if (sat > INTTOFIX(100))
                sat = INTTOFIX(100);

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_iterate(vector, ctx);
            if (!tokenIsChar(token, ','))
                goto invalid;


            /* lightness */
            consumeWhitespace(vector, ctx);

            token = parserutils_vector_iterate(vector, ctx);
            if ((token == NULL) || (token->type != CSS_TOKEN_PERCENTAGE))
                goto invalid;

            lit = css__number_from_lwc_string(token->idata, false, &consumed);
            if (consumed != lwc_string_length(token->idata))
                goto invalid; /* failed to consume the whole string as a number */

            /* Normalise lightness to the range [0, 100] */
            if (lit < INTTOFIX(0))
                lit = INTTOFIX(0);
            else if (lit > INTTOFIX(100))
                lit = INTTOFIX(100);

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_iterate(vector, ctx);

            if (colour_channels == 6) {
                /* alpha */

                if (!tokenIsChar(token, ','))
                    goto invalid;

                consumeWhitespace(vector, ctx);

                token = parserutils_vector_iterate(vector, ctx);
                if ((token == NULL) || (token->type != CSS_TOKEN_NUMBER))
                    goto invalid;

                alpha = css__number_from_lwc_string(token->idata, false, &consumed);
                if (consumed != lwc_string_length(token->idata))
                    goto invalid; /* failed to consume the whole string as a number */

                alpha = FIXTOINT(FMUL(alpha, F_255));

                consumeWhitespace(vector, ctx);

                token = parserutils_vector_iterate(vector, ctx);

            }

            if (!tokenIsChar(token, ')'))
                goto invalid;

            /* have a valid HSV entry, convert to RGB */
            HSL_to_RGB(hue, sat, lit, &r, &g, &b);

            /* apply alpha */
            if (alpha > 255)
                a = 255;
            else if (alpha < 0)
                a = 0;
            else
                a = alpha;

        }
        else {
            goto invalid;
        }

        *result = ((unsigned)a << 24) | (r << 16) | (g << 8) | b;
    }

    *value = COLOR_SET;

    return CSS_OK;

invalid:
    *ctx = orig_ctx;
    return CSS_INVALID;
}

/**
 * Parse a named colour
 *
 * \param c       Parsing context
 * \param data    Colour name string
 * \param result  Pointer to location to receive result
 * \return CSS_OK      on success,
 *         CSS_INVALID if the colour name is unknown
 */
css_error css__parse_named_colour(css_language* c, lwc_string* data,
    uint32_t* result)
{
    static const uint32_t colourmap[LAST_COLOUR + 1 - FIRST_COLOUR] = {
        0xfff0f8ff, /* ALICEBLUE */
        0xfffaebd7, /* ANTIQUEWHITE */
        0xff00ffff, /* AQUA */
        0xff7fffd4, /* AQUAMARINE */
        0xfff0ffff, /* AZURE */
        0xfff5f5dc, /* BEIGE */
        0xffffe4c4, /* BISQUE */
        0xff000000, /* BLACK */
        0xffffebcd, /* BLANCHEDALMOND */
        0xff0000ff, /* BLUE */
        0xff8a2be2, /* BLUEVIOLET */
        0xffa52a2a, /* BROWN */
        0xffdeb887, /* BURLYWOOD */
        0xff5f9ea0, /* CADETBLUE */
        0xff7fff00, /* CHARTREUSE */
        0xffd2691e, /* CHOCOLATE */
        0xffff7f50, /* CORAL */
        0xff6495ed, /* CORNFLOWERBLUE */
        0xfffff8dc, /* CORNSILK */
        0xffdc143c, /* CRIMSON */
        0xff00ffff, /* CYAN */
        0xff00008b, /* DARKBLUE */
        0xff008b8b, /* DARKCYAN */
        0xffb8860b, /* DARKGOLDENROD */
        0xffa9a9a9, /* DARKGRAY */
        0xff006400, /* DARKGREEN */
        0xffa9a9a9, /* DARKGREY */
        0xffbdb76b, /* DARKKHAKI */
        0xff8b008b, /* DARKMAGENTA */
        0xff556b2f, /* DARKOLIVEGREEN */
        0xffff8c00, /* DARKORANGE */
        0xff9932cc, /* DARKORCHID */
        0xff8b0000, /* DARKRED */
        0xffe9967a, /* DARKSALMON */
        0xff8fbc8f, /* DARKSEAGREEN */
        0xff483d8b, /* DARKSLATEBLUE */
        0xff2f4f4f, /* DARKSLATEGRAY */
        0xff2f4f4f, /* DARKSLATEGREY */
        0xff00ced1, /* DARKTURQUOISE */
        0xff9400d3, /* DARKVIOLET */
        0xffff1493, /* DEEPPINK */
        0xff00bfff, /* DEEPSKYBLUE */
        0xff696969, /* DIMGRAY */
        0xff696969, /* DIMGREY */
        0xff1e90ff, /* DODGERBLUE */
        0xffd19275, /* FELDSPAR */
        0xffb22222, /* FIREBRICK */
        0xfffffaf0, /* FLORALWHITE */
        0xff228b22, /* FORESTGREEN */
        0xffff00ff, /* FUCHSIA */
        0xffdcdcdc, /* GAINSBORO */
        0xfff8f8ff, /* GHOSTWHITE */
        0xffffd700, /* GOLD */
        0xffdaa520, /* GOLDENROD */
        0xff808080, /* GRAY */
        0xff008000, /* GREEN */
        0xffadff2f, /* GREENYELLOW */
        0xff808080, /* GREY */
        0xfff0fff0, /* HONEYDEW */
        0xffff69b4, /* HOTPINK */
        0xffcd5c5c, /* INDIANRED */
        0xff4b0082, /* INDIGO */
        0xfffffff0, /* IVORY */
        0xfff0e68c, /* KHAKI */
        0xffe6e6fa, /* LAVENDER */
        0xfffff0f5, /* LAVENDERBLUSH */
        0xff7cfc00, /* LAWNGREEN */
        0xfffffacd, /* LEMONCHIFFON */
        0xffadd8e6, /* LIGHTBLUE */
        0xfff08080, /* LIGHTCORAL */
        0xffe0ffff, /* LIGHTCYAN */
        0xfffafad2, /* LIGHTGOLDENRODYELLOW */
        0xffd3d3d3, /* LIGHTGRAY */
        0xff90ee90, /* LIGHTGREEN */
        0xffd3d3d3, /* LIGHTGREY */
        0xffffb6c1, /* LIGHTPINK */
        0xffffa07a, /* LIGHTSALMON */
        0xff20b2aa, /* LIGHTSEAGREEN */
        0xff87cefa, /* LIGHTSKYBLUE */
        0xff8470ff, /* LIGHTSLATEBLUE */
        0xff778899, /* LIGHTSLATEGRAY */
        0xff778899, /* LIGHTSLATEGREY */
        0xffb0c4de, /* LIGHTSTEELBLUE */
        0xffffffe0, /* LIGHTYELLOW */
        0xff00ff00, /* LIME */
        0xff32cd32, /* LIMEGREEN */
        0xfffaf0e6, /* LINEN */
        0xffff00ff, /* MAGENTA */
        0xff800000, /* MAROON */
        0xff66cdaa, /* MEDIUMAQUAMARINE */
        0xff0000cd, /* MEDIUMBLUE */
        0xffba55d3, /* MEDIUMORCHID */
        0xff9370db, /* MEDIUMPURPLE */
        0xff3cb371, /* MEDIUMSEAGREEN */
        0xff7b68ee, /* MEDIUMSLATEBLUE */
        0xff00fa9a, /* MEDIUMSPRINGGREEN */
        0xff48d1cc, /* MEDIUMTURQUOISE */
        0xffc71585, /* MEDIUMVIOLETRED */
        0xff191970, /* MIDNIGHTBLUE */
        0xfff5fffa, /* MINTCREAM */
        0xffffe4e1, /* MISTYROSE */
        0xffffe4b5, /* MOCCASIN */
        0xffffdead, /* NAVAJOWHITE */
        0xff000080, /* NAVY */
        0xfffdf5e6, /* OLDLACE */
        0xff808000, /* OLIVE */
        0xff6b8e23, /* OLIVEDRAB */
        0xffffa500, /* ORANGE */
        0xffff4500, /* ORANGERED */
        0xffda70d6, /* ORCHID */
        0xffeee8aa, /* PALEGOLDENROD */
        0xff98fb98, /* PALEGREEN */
        0xffafeeee, /* PALETURQUOISE */
        0xffdb7093, /* PALEVIOLETRED */
        0xffffefd5, /* PAPAYAWHIP */
        0xffffdab9, /* PEACHPUFF */
        0xffcd853f, /* PERU */
        0xffffc0cb, /* PINK */
        0xffdda0dd, /* PLUM */
        0xffb0e0e6, /* POWDERBLUE */
        0xff800080, /* PURPLE */
        0xffff0000, /* RED */
        0xffbc8f8f, /* ROSYBROWN */
        0xff4169e1, /* ROYALBLUE */
        0xff8b4513, /* SADDLEBROWN */
        0xfffa8072, /* SALMON */
        0xfff4a460, /* SANDYBROWN */
        0xff2e8b57, /* SEAGREEN */
        0xfffff5ee, /* SEASHELL */
        0xffa0522d, /* SIENNA */
        0xffc0c0c0, /* SILVER */
        0xff87ceeb, /* SKYBLUE */
        0xff6a5acd, /* SLATEBLUE */
        0xff708090, /* SLATEGRAY */
        0xff708090, /* SLATEGREY */
        0xfffffafa, /* SNOW */
        0xff00ff7f, /* SPRINGGREEN */
        0xff4682b4, /* STEELBLUE */
        0xffd2b48c, /* TAN */
        0xff008080, /* TEAL */
        0xffd8bfd8, /* THISTLE */
        0xffff6347, /* TOMATO */
        0xff40e0d0, /* TURQUOISE */
        0xffee82ee, /* VIOLET */
        0xffd02090, /* VIOLETRED */
        0xfff5deb3, /* WHEAT */
        0xffffffff, /* WHITE */
        0xfff5f5f5, /* WHITESMOKE */
        0xffffff00, /* YELLOW */
        0xff9acd32  /* YELLOWGREEN */
    };
    int i;
    bool match;

    for (i = FIRST_COLOUR; i <= LAST_COLOUR; i++) {
        if (lwc_string_caseless_isequal(data, c->strings[i],
            &match) == lwc_error_ok && match)
            break;
    }

    if (i <= LAST_COLOUR) {
        /* Known named colour */
        *result = colourmap[i - FIRST_COLOUR];
        return CSS_OK;
    }

    /* We don't know this colour name; ask the client */
    if (c->sheet->color != NULL)
        return c->sheet->color(c->sheet->color_pw, data, result);

    /* Invalid colour name */
    return CSS_INVALID;
}

/**
 * Parse a hash colour (#rgb or #rrggbb)
 *
 * \param data    Pointer to colour string
 * \param result  Pointer to location to receive result (AARRGGBB)
 * \return CSS_OK      on success,
 *         CSS_INVALID if the input is invalid
 */
css_error css__parse_hash_colour(lwc_string* data, uint32_t* result)
{
    uint8_t r = 0, g = 0, b = 0, a = 0xff;
    size_t len = lwc_string_length(data);
    const char* input = lwc_string_data(data);

    if (len == 3 && isHex(input[0]) && isHex(input[1]) &&
        isHex(input[2])) {
        r = charToHex(input[0]);
        g = charToHex(input[1]);
        b = charToHex(input[2]);

        r |= (r << 4);
        g |= (g << 4);
        b |= (b << 4);
    }
    else if (len == 6 && isHex(input[0]) && isHex(input[1]) &&
        isHex(input[2]) && isHex(input[3]) &&
        isHex(input[4]) && isHex(input[5])) {
        r = (charToHex(input[0]) << 4);
        r |= charToHex(input[1]);
        g = (charToHex(input[2]) << 4);
        g |= charToHex(input[3]);
        b = (charToHex(input[4]) << 4);
        b |= charToHex(input[5]);
    }
    else
        return CSS_INVALID;

    *result = ((unsigned)a << 24) | (r << 16) | (g << 8) | b;

    return CSS_OK;
}

/**
 * Parse a unit specifier
 *
 * \param c             Parsing context
 * \param vector        Vector of tokens to process
 * \param ctx           Pointer to current vector iteration context
 * \param default_unit  The default unit to use if none specified
 * \param length        Pointer to location to receive length
 * \param unit          Pointer to location to receive unit
 * \return CSS_OK      on success,
 *         CSS_INVALID if the tokens do not form a valid unit
 *
 * Post condition: \a *ctx is updated with the next token to process
 *                 If the input is invalid, then \a *ctx remains unchanged.
 */
css_error css__parse_unit_specifier(css_language* c,
    const parserutils_vector* vector, int* ctx,
    uint32_t default_unit,
    css_fixed* length, uint32_t* unit)
{
    int orig_ctx = *ctx;
    const css_token* token;
    css_fixed num;
    size_t consumed = 0;
    css_error error;

    consumeWhitespace(vector, ctx);

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL || (token->type != CSS_TOKEN_DIMENSION &&
        token->type != CSS_TOKEN_NUMBER &&
        token->type != CSS_TOKEN_PERCENTAGE)) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    num = css__number_from_lwc_string(token->idata, false, &consumed);

    if (token->type == CSS_TOKEN_DIMENSION) {
        size_t len = lwc_string_length(token->idata);
        const char* data = lwc_string_data(token->idata);
        css_unit temp_unit = CSS_UNIT_PX;

        error = css__parse_unit_keyword(data + consumed, len - consumed,
            &temp_unit);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        *unit = (uint32_t)temp_unit;
    }
    else if (token->type == CSS_TOKEN_NUMBER) {
        /* Non-zero values are permitted in quirks mode */
        if (num != 0) {
            if (c->sheet->quirks_allowed) {
                c->sheet->quirks_used = true;
            }
            else {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }

        *unit = default_unit;

        if (c->sheet->quirks_allowed) {
            /* Also, in quirks mode, we need to cater for
             * dimensions separated from their units by whitespace
             * (e.g. "0 px")
             */
            int temp_ctx = *ctx;
            css_unit temp_unit;

            consumeWhitespace(vector, &temp_ctx);

            /* Try to parse the unit keyword, ignoring errors */
            token = parserutils_vector_iterate(vector, &temp_ctx);
            if (token != NULL && token->type == CSS_TOKEN_IDENT) {
                error = css__parse_unit_keyword(
                    lwc_string_data(token->idata),
                    lwc_string_length(token->idata),
                    &temp_unit);
                if (error == CSS_OK) {
                    c->sheet->quirks_used = true;
                    *ctx = temp_ctx;
                    *unit = (uint32_t)temp_unit;
                }
            }
        }
    }
    else {
        /* Percentage -- number must be entire token data */
        if (consumed != lwc_string_length(token->idata)) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        *unit = UNIT_PCT;
    }

    *length = num;

    return CSS_OK;
}

/**
 * Parse a unit keyword
 *
 * \param ptr   Pointer to keyword string
 * \param len   Length, in bytes, of string
 * \param unit  Pointer to location to receive computed unit
 * \return CSS_OK      on success,
 *         CSS_INVALID on encountering an unknown keyword
 */
css_error css__parse_unit_keyword(const char* ptr, size_t len, uint32_t* unit)
{
    if (len == 4) {
        if (strncasecmp(ptr, "grad", 4) == 0)
            *unit = UNIT_GRAD;
        else if (strncasecmp(ptr, "turn", 4) == 0)
            *unit = UNIT_TURN;
        else if (strncasecmp(ptr, "dppx", 4) == 0)
            *unit = UNIT_DPPX;
        else if (strncasecmp(ptr, "dpcm", 4) == 0)
            *unit = UNIT_DPCM;
        else if (strncasecmp(ptr, "vmin", 4) == 0)
            *unit = UNIT_VMIN;
        else if (strncasecmp(ptr, "vmax", 4) == 0)
            *unit = UNIT_VMAX;
        else
            return CSS_INVALID;
    }
    else if (len == 3) {
        if (strncasecmp(ptr, "kHz", 3) == 0)
            *unit = UNIT_KHZ;
        else if (strncasecmp(ptr, "deg", 3) == 0)
            *unit = UNIT_DEG;
        else if (strncasecmp(ptr, "rad", 3) == 0)
            *unit = UNIT_RAD;
        else if (strncasecmp(ptr, "cap", 3) == 0)
            *unit = UNIT_CAP;
        else if (strncasecmp(ptr, "rem", 3) == 0)
            *unit = UNIT_REM;
        else if (strncasecmp(ptr, "rlh", 3) == 0)
            *unit = UNIT_RLH;
        else if (strncasecmp(ptr, "dpi", 3) == 0)
            *unit = UNIT_DPI;
        else
            return CSS_INVALID;
    }
    else if (len == 2) {
        if (strncasecmp(ptr, "Hz", 2) == 0)
            *unit = UNIT_HZ;
        else if (strncasecmp(ptr, "ms", 2) == 0)
            *unit = UNIT_MS;
        else if (strncasecmp(ptr, "px", 2) == 0)
            *unit = UNIT_PX;
        else if (strncasecmp(ptr, "ex", 2) == 0)
            *unit = UNIT_EX;
        else if (strncasecmp(ptr, "em", 2) == 0)
            *unit = UNIT_EM;
        else if (strncasecmp(ptr, "in", 2) == 0)
            *unit = UNIT_IN;
        else if (strncasecmp(ptr, "cm", 2) == 0)
            *unit = UNIT_CM;
        else if (strncasecmp(ptr, "mm", 2) == 0)
            *unit = UNIT_MM;
        else if (strncasecmp(ptr, "pt", 2) == 0)
            *unit = UNIT_PT;
        else if (strncasecmp(ptr, "pc", 2) == 0)
            *unit = UNIT_PC;
        else if (strncasecmp(ptr, "ch", 2) == 0)
            *unit = UNIT_CH;
        else if (strncasecmp(ptr, "ic", 2) == 0)
            *unit = UNIT_IC;
        else if (strncasecmp(ptr, "lh", 2) == 0)
            *unit = UNIT_LH;
        else if (strncasecmp(ptr, "vh", 2) == 0)
            *unit = UNIT_VH;
        else if (strncasecmp(ptr, "vw", 2) == 0)
            *unit = UNIT_VW;
        else if (strncasecmp(ptr, "vi", 2) == 0)
            *unit = UNIT_VI;
        else if (strncasecmp(ptr, "vb", 2) == 0)
            *unit = UNIT_VB;
        else
            return CSS_INVALID;
    }
    else if (len == 1) {
        if (strncasecmp(ptr, "s", 1) == 0)
            *unit = UNIT_S;
        else if (strncasecmp(ptr, "q", 1) == 0)
            *unit = UNIT_Q;
        else
            return CSS_INVALID;
    }
    else
        return CSS_INVALID;

    return CSS_OK;
}

/**
 * Create a string from a list of IDENT/S tokens if the next token is IDENT
 * or references the next token's string if it is a STRING
 *
 * \param c          Parsing context
 * \param vector     Vector containing tokens
 * \param ctx        Vector iteration context
 * \param reserved   Callback to determine if an identifier is reserved
 * \param result     Pointer to location to receive resulting string
 * \return CSS_OK on success, appropriate error otherwise.
 *
 * Post condition: \a *ctx is updated with the next token to process
 *                 If the input is invalid, then \a *ctx remains unchanged.
 *
 *                 The resulting string's reference is passed to the caller
 */
css_error css__ident_list_or_string_to_string(css_language* c,
    const parserutils_vector* vector, int* ctx,
    bool (*reserved)(css_language* c, const css_token* ident),
    lwc_string** result)
{
    const css_token* token;

    token = parserutils_vector_peek(vector, *ctx);
    if (token == NULL)
        return CSS_INVALID;

    if (token->type == CSS_TOKEN_STRING) {
        token = parserutils_vector_iterate(vector, ctx);
        *result = lwc_string_ref(token->idata);
        return CSS_OK;
    }
    else 	if (token->type == CSS_TOKEN_IDENT) {
        return css__ident_list_to_string(c, vector, ctx, reserved,
            result);
    }

    return CSS_INVALID;
}

/**
 * Create a string from a list of IDENT/S tokens
 *
 * \param c          Parsing context
 * \param vector     Vector containing tokens
 * \param ctx        Vector iteration context
 * \param reserved   Callback to determine if an identifier is reserved
 * \param result     Pointer to location to receive resulting string
 * \return CSS_OK on success, appropriate error otherwise.
 *
 * Post condition: \a *ctx is updated with the next token to process
 *                 If the input is invalid, then \a *ctx remains unchanged.
 *
 *                 The resulting string's reference is passed to the caller
 */
css_error css__ident_list_to_string(css_language* c,
    const parserutils_vector* vector, int* ctx,
    bool (*reserved)(css_language* c, const css_token* ident),
    lwc_string** result)
{
    int orig_ctx = *ctx;
    const css_token* token;
    css_error error = CSS_OK;
    parserutils_buffer* buffer;
    parserutils_error perror;
    lwc_string* interned;
    lwc_error lerror;

    perror = parserutils_buffer_create(&buffer);
    if (perror != PARSERUTILS_OK)
        return css_error_from_parserutils_error(perror);

    /* We know this token exists, and is an IDENT */
    token = parserutils_vector_iterate(vector, ctx);

    /* Consume all subsequent IDENT or S tokens */
    while (token != NULL && (token->type == CSS_TOKEN_IDENT ||
        token->type == CSS_TOKEN_S)) {
        if (token->type == CSS_TOKEN_IDENT) {
            /* IDENT -- if reserved, reject style */
            if (reserved != NULL && reserved(c, token)) {
                error = CSS_INVALID;
                goto cleanup;
            }

            perror = parserutils_buffer_append(buffer,
                (const uint8_t*)lwc_string_data(token->idata),
                lwc_string_length(token->idata));
        }
        else {
            /* S */
            perror = parserutils_buffer_append(buffer,
                (const uint8_t*)" ", 1);
        }

        if (perror != PARSERUTILS_OK) {
            error = css_error_from_parserutils_error(perror);
            goto cleanup;
        }

        token = parserutils_vector_iterate(vector, ctx);
    }

    /* Rewind context by one step if we consumed an unacceptable token */
    if (token != NULL)
        *ctx = *ctx - 1;

    /* Strip trailing whitespace */
    while (buffer->length > 0 && buffer->data[buffer->length - 1] == ' ')
        buffer->length--;

    /* Intern the buffer contents */
    lerror = lwc_intern_string((char*)buffer->data, buffer->length, &interned);
    if (lerror != lwc_error_ok) {
        error = css_error_from_lwc_error(lerror);
        goto cleanup;
    }

    *result = interned;

cleanup:
    parserutils_buffer_destroy(buffer);

    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}

/**
 * Parse a comma separated list, converting to bytecode
 *
 * \param c          Parsing context
 * \param vector     Vector of tokens to process
 * \param ctx        Pointer to vector iteration context
 * \param reserved   Callback to determine if an identifier is reserved
 * \param get_value  Callback to retrieve bytecode value for a token
 * \param style      Pointer to output style
 * \return CSS_OK      on success,
 *         CSS_INVALID if the input is invalid
 *
 * Post condition: \a *ctx is updated with the next token to process
 *                 If the input is invalid, then \a *ctx remains unchanged.
 */
css_error css__comma_list_to_style(css_language* c,
    const parserutils_vector* vector, int* ctx,
    bool (*reserved)(css_language* c, const css_token* ident),
    css_code_t(*get_value)(css_language* c, const css_token* token, bool first),
    css_style* result)
{
    int orig_ctx = *ctx;
    int prev_ctx = orig_ctx;
    const css_token* token;
    bool first = true;
    css_error error = CSS_OK;

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    while (token != NULL) {
        if (token->type == CSS_TOKEN_IDENT) {
            css_code_t value = get_value(c, token, first);

            if (reserved(c, token) == false) {
                lwc_string* str = NULL;
                uint32_t snumber;

                *ctx = prev_ctx;

                error = css__ident_list_to_string(c, vector, ctx,
                    reserved, &str);
                if (error != CSS_OK)
                    goto cleanup;

                error = css__stylesheet_string_add(c->sheet,
                    str, &snumber);
                if (error != CSS_OK)
                    goto cleanup;

                error = css__stylesheet_style_append(result,
                    value);
                if (error != CSS_OK)
                    goto cleanup;

                error = css__stylesheet_style_append(result,
                    snumber);
                if (error != CSS_OK)
                    goto cleanup;
            }
            else {
                error = css__stylesheet_style_append(result,
                    value);
                if (error != CSS_OK)
                    goto cleanup;
            }
        }
        else if (token->type == CSS_TOKEN_STRING) {
            css_code_t value = get_value(c, token, first);
            uint32_t snumber;

            error = css__stylesheet_string_add(c->sheet,
                lwc_string_ref(token->idata), &snumber);
            if (error != CSS_OK)
                goto cleanup;

            error = css__stylesheet_style_append(result, value);
            if (error != CSS_OK)
                goto cleanup;

            error = css__stylesheet_style_append(result, snumber);
            if (error != CSS_OK)
                goto cleanup;
        }
        else {
            error = CSS_INVALID;
            goto cleanup;
        }

        consumeWhitespace(vector, ctx);

        token = parserutils_vector_peek(vector, *ctx);
        if (token != NULL && tokenIsChar(token, ',')) {
            parserutils_vector_iterate(vector, ctx);

            consumeWhitespace(vector, ctx);

            token = parserutils_vector_peek(vector, *ctx);
            if (token == NULL || (token->type != CSS_TOKEN_IDENT &&
                token->type != CSS_TOKEN_STRING)) {
                error = CSS_INVALID;
                goto cleanup;
            }
        }
        else {
            break;
        }

        first = false;

        prev_ctx = *ctx;

        token = parserutils_vector_iterate(vector, ctx);
    }

cleanup:
    if (error != CSS_OK)
        *ctx = orig_ctx;

    return error;
}


/*********************************************************************************
voice_family
*
*********************************************************************************/
/*
 * This file is part of LibCSS.
 * Licensed under the MIT License,
 *		  http://www.opensource.org/licenses/mit-license.php
 * Copyright 2009 John-Mark Bell <jmb@netsurf-browser.org>
 */

#include <assert.h>
#include <string.h>

#include "thirdparty/libcss/libcss/bytecode/bytecode.h"
#include "thirdparty/libcss/libcss/bytecode/opcodes.h"
#include "thirdparty/libcss/libcss/parse/properties/properties.h"


 /**
  * Determine if a given voice-family ident is reserved
  *
  * \param c	 Parsing context
  * \param ident	 IDENT to consider
  * \return True if IDENT is reserved, false otherwise
  */
static bool voice_family_reserved(css_language* c, const css_token* ident)
{
    bool match;

    return (lwc_string_caseless_isequal(
        ident->idata, c->strings[MALE],
        &match) == lwc_error_ok && match) ||
        (lwc_string_caseless_isequal(
            ident->idata, c->strings[FEMALE],
            &match) == lwc_error_ok && match) ||
        (lwc_string_caseless_isequal(
            ident->idata, c->strings[CHILD],
            &match) == lwc_error_ok && match);
}

/**
 * Convert a voice-family token into a bytecode value
 *
 * \param c	 Parsing context
 * \param token	 Token to consider
 * \return Bytecode value
 */
static css_code_t voice_family_value(css_language* c, const css_token* token, bool first)
{
    uint16_t value;
    bool match;

    if (token->type == CSS_TOKEN_IDENT) {
        if ((lwc_string_caseless_isequal(
            token->idata, c->strings[MALE],
            &match) == lwc_error_ok && match))
            value = VOICE_FAMILY_MALE;
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[FEMALE],
            &match) == lwc_error_ok && match))
            value = VOICE_FAMILY_FEMALE;
        else if ((lwc_string_caseless_isequal(
            token->idata, c->strings[CHILD],
            &match) == lwc_error_ok && match))
            value = VOICE_FAMILY_CHILD;
        else
            value = VOICE_FAMILY_IDENT_LIST;
    }
    else {
        value = VOICE_FAMILY_STRING;
    }

    return first ? buildOPV(CSS_PROP_VOICE_FAMILY, 0, value) : value;
}

/**
 * Parse voice-family
 *
 * \param c	  Parsing context
 * \param vector  Vector of tokens to process
 * \param ctx	  Pointer to vector iteration context
 * \param result  Pointer to location to receive resulting style
 * \return CSS_OK on success,
 *	 CSS_NOMEM on memory exhaustion,
 *	 CSS_INVALID if the input is not valid
 *
 * Post condition: \a *ctx is updated with the next token to process
 *		 If the input is invalid, then \a *ctx remains unchanged.
 */
css_error css__parse_voice_family(css_language* c,
    const parserutils_vector* vector, int* ctx,
    css_style* result)
{
    int orig_ctx = *ctx;
    css_error error;
    const css_token* token;
    bool match;

    /* [ IDENT+ | STRING ] [ ',' [ IDENT+ | STRING ] ]* | IDENT(inherit)
     *
     * In the case of IDENT+, any whitespace between tokens is collapsed to
     * a single space
     */

    token = parserutils_vector_iterate(vector, ctx);
    if (token == NULL || (token->type != CSS_TOKEN_IDENT &&
        token->type != CSS_TOKEN_STRING)) {
        *ctx = orig_ctx;
        return CSS_INVALID;
    }

    if (token->type == CSS_TOKEN_IDENT &&
        (lwc_string_caseless_isequal(
            token->idata, c->strings[INHERIT],
            &match) == lwc_error_ok && match)) {
        error = css_stylesheet_style_inherit(result, CSS_PROP_VOICE_FAMILY);
    }
    else {
        *ctx = orig_ctx;

        error = css__comma_list_to_style(c, vector, ctx,
            voice_family_reserved, voice_family_value,
            result);
        if (error != CSS_OK) {
            *ctx = orig_ctx;
            return error;
        }

        error = css__stylesheet_style_append(result, VOICE_FAMILY_END);
    }

    if (error != CSS_OK) {
        *ctx = orig_ctx;
        return error;
    }

    return CSS_OK;
}
